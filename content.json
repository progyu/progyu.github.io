{"meta":{"title":"progyu 개발 블로그","subtitle":null,"description":null,"author":"Lee Gyuha","url":"http://progyu.github.io","root":"/"},"pages":[{"title":"","date":"2019-05-30T12:09:35.277Z","updated":"2019-05-30T12:09:35.277Z","comments":true,"path":"about/index.html","permalink":"http://progyu.github.io/about/index.html","excerpt":"","text":"About Contactemail: rocket7101@gmail.com"}],"posts":[{"title":"191103_TIL(Search & Sort in JS)","slug":"191103-TIL-Search-Sort-in-JS","date":"2019-11-03T13:48:28.000Z","updated":"2019-11-03T13:48:48.445Z","comments":true,"path":"2019/11/03/191103-TIL-Search-Sort-in-JS/","link":"","permalink":"http://progyu.github.io/2019/11/03/191103-TIL-Search-Sort-in-JS/","excerpt":"","text":"자바스트립트 검색과 정렬검색과 정렬의 정의검색 자료를 얻기 위해 자료구조의 항목들을 반복적으로 접근하는 것. 정렬 자료구조의 항목들을 순서대로 위치시는 것. 배열이 정렬됐는지 여부에 따른 검색 기법 두 가지선형검색 정렬되지 않은 자료와 정렬된 자료 모두 사용 가능하기 때문에 유연하다. 최악의 경우 전체 배열을 순회해야 하기 때문에 시간 복잡도는 O(n)이다. 배열의 모든 항목을 확인해야 한다. 배열이 정렬되지 않은 경우에 선형 검색을 사용해야 한다. 이진검색 정렬된 자료에 대해 사용. 시간 복잡도가 선형 검색의 시간 복잡도보다 낮은 장점이 있다. 중간 값을 확인하여 원하는 값보다 중간 값이 큰지 작은지 확인하여 큰 경우 중간 값보다 큰 쪽을 검색하고 작은 경우 중간 값보다 작은 쪽만 검색한다. 이진 검색 알고리즘은 배열을 계속해서 두 부분으로 나눈다. 1234567891011121314151617181920// 이진 검색 알고리즘 구현// 중간 값이 검색 값과 일치하는지 확인하고 검색 값이 중간 값보다 큰 경우 검색 범위의 하한값을 중간값에 1을 더한 값으로 설정하고 검색 값이 중간 값보다 작은 경우 검색 범위의 상한값을 중간값에 1을 뺀 값으로 설정한다.function binarySearch(array, n) &#123; var lowIndex = 0, highIndex = array.length-1; while(lowIndex &lt;= highIndex) &#123; var midIndex = Math.floor((highIndex+lowIndex) / 2); if(array[midIndex] == n) &#123; return midIndex; &#125; else if(n&gt;array[midIndex]) &#123; lowIndex = midIndex+1; &#125; else &#123; highIndex = midIndex-1; &#125; &#125; return -1;&#125;console.log(binarySearch([1,2,3,4], 4)); // 3console.log(binarySearch([1,2,3,4], 7)); // -1 정렬 알고리즘거품 정렬(bubble sort)거품 정렬은 가장 간단한 정렬 알고리즘이다. 전체 배열을 순회하면서 항목이 다른 항목보다 큰 경우 두 항목을 교환한다. 123456789101112function bubbleSort(array) &#123; for (var i = 0, arrayLength = array.length; i &lt; arrayLength; i++) &#123; for (var j = 0; j &lt; arrayLength - 1 - i; j++) &#123; if (array[j] &gt; array[j+1]) &#123; var temp = array[j]; array[j] = array[j+1]; array[j+1] = temp; &#125; &#125; &#125; return array;&#125; 거품 정렬은 최악의 시간 복잡도를 지닌 정렬이다. 다른 정렬 알고리즘은 배열의 이미 정렬된 부분을 활용하는데 비해 거품 정렬은 모든 가능한짝을 비교하기 때문이다. 시간 복잡도 : O(n^2) 선택 정렬(selection sort)가장 작은 항목을 찾아서 해당 항목을 배열의 현 위치에 삽입하는 방식으로 동작한다. 거품 정렬보다는 조금 더 나은 퍼포먼스를 보이지만 선택 정렬 역시 시간 복잡도는 O(n^2)이다. 123456789101112131415161718192021222324252627function swap(array, index1, index2) &#123; var temp = array[index1]; array[index1] = array[index2]; array[index2] = temp;&#125;function selectionSort(items) &#123; var len = items.length, min; for (var i = 0; i &lt; len; i++) &#123; // 가장 작은 원소를 현재 위치로 설정한다. min = i; // 더 작은 원소가 있는지 배열의 나머지 항목을 확인한다. for (j = i + 1; j &lt; len; j++) &#123; if (items[j] &lt; items[min]) &#123; min = j; &#125; &#125; // 현재 위치가 가장 작은 원소가 아니라면 원소들을 교환한다. if (i != min) &#123; swap(items, i, min); &#125; &#125; return items;&#125; 삽입 정렬(insertion sort)삽입 정렬은 배열을 순차적으로 검색하면서 정렬되지 않은 항목들을 배열의 왼쪽의 정렬된 부분으로 이동시킨다. 123456789101112131415161718192021function insertionSort(items) &#123; var len = items.length, // 배열의 원소 수 value, // 현재 비교 중인 값 i, // 정렬되지 않은 부분의 인덱스 j; // 정렬된 부분의 인덱스 for (i = 0; i &lt; len; i++) &#123; // 현재 값이 이후에 이동될 수도 있기 때문에 저장한다. value = items[i]; // 정렬된 부분의 값이 정렬되지 않은 부분의 값보다 큰 경우 // 정렬된 부분의 모든 항목을 하나씩 이동시킨다. // 이는 값을 삽입할 공간을 만드는 것이다. for (j = i - 1; j &gt; -1 &amp;&amp; items[j] &gt; value; j--) &#123; items[j + 1] = items[j]; &#125; items[j + 1] = value; &#125; return items;&#125; 외부 for 루프는 배열 인덱스를 순회하고 내부 for 루프는 정렬되지 않은 항목들을 배열의 왼쪽의 정렬된 부분으로 이동시킨다. 시간 복잡도 : O(n^2) 빠른 정렬(quick sort)빠른 정렬은 기준점을 획득한 다음 해당 기준점을 기준으로 배열을 나눈다. 모든 항목이 정렬될 때까지 이 과정을 거친다. 가장 이상적인 기준점은 배열의 중간 값이다. 하지만 정렬되지 않은 배열의 중간 값을 얻기 위해서는 선형 시간이 걸린다. 따라서 일반적으로 분할 부분의 첫 번째 항목과 중간 항목, 마지막 항목의 중간 값을 취해 기준점을 얻는다. 시간복잡도 : 평균 O(nlogn), 최악의 경우 O(n^2) 평균 성능이 최적화되어야 하는 경우에 빠른 정렬 알고리즘 사용을 권장한다. 123456789101112131415161718192021222324252627282930313233343536373839function quickSort(items) &#123; return quickSortHelper(items, 0, items.length - 1);&#125;function quickSortHelper(items, left, right) &#123; var index; if (items.length &gt; 1) &#123; index = partition(items, left, right); if (left &lt; index - 1) &#123; quickSortHelper(items, left, index - 1); &#125; if (index &lt; right) &#123; quickSortHelper(items, index, right); &#125; &#125; return items;&#125;function partition(array, left, right) &#123; var pivot = array[Math.floor((right + left) / 2)]; while (left &lt;= right) &#123; while (pivot &gt; array[left]) &#123; left++; &#125; while (pivot &lt; array[right]) &#123; right--; &#125; if (left &lt;= right) &#123; var temp = array[left]; array[left] = array[right]; array[right] = temp; left++; right--; &#125; &#125; return left;&#125; 병합 정렬(merge sort) 병합 정렬은 각 하위 배열에 하나의 항목이 존재할 때까지 배열을 하위 배열로 나눈다. 그리고 나서 각 하위 배열을 정렬된 순서로 연결(병합)한다. merge 함수는 양쪽 배열의 모든 항목을 정렬된 순서로 더해서 결과 배열에 저장해야 한다. 이를 위해서는 각 배열의 인덱스르르 생성해 이미 비교한 항목들을 추적해야한다. 한 배열의 모든 항목을 다 사용한 뒤 남은 항목들을 결과 배열에 더하면 된다. 12345678910111213141516171819202122232425262728function merge(leftA, rightA)&#123; var results= [], leftIndex= 0, rightIndex= 0; while (leftIndex &lt; leftA.length &amp;&amp; rightIndex &lt; rightA.length) &#123; if( leftA[leftIndex]&lt;rightA[rightIndex] )&#123; results.push(leftA[leftIndex++]); &#125; else &#123; results.push(rightA[rightIndex++]); &#125; &#125; var leftRemains = leftA.slice(leftIndex), rightRemains = rightA.slice(rightIndex); // 남은 항목들을 결과 배열에 추가한다. return results.concat(leftRemains).concat(rightRemains);&#125;function mergeSort(array) &#123; if(array.length&lt;2)&#123; return array; // 기저 조건: 항목이 하나뿐이라서 해당 배열은 이미 정렬된 상태이다. &#125; var midpoint = Math.floor((array.length)/2), leftArray = array.slice(0, midpoint), rightArray = array.slice(midpoint); return merge(mergeSort(leftArray), mergeSort(rightArray));&#125; merge 함수는 두 배열을 가지고 하나의 결과 배열로 병합한다. 순서를 지키기위해 배열을 병합하면서 배열의 항목들을 비교해야 한다. mergesort 함수는 큰 배열을 두 개의 개별적인 배열로 분할한 다음 재귀적으로 merge를 호출한다. 안정적인 정렬이 필요한 경우에 병합 정렬을 사용한다. 안정적인 정렬은 동일한 값을 지닌 항목들의 순서가 바뀌지 않음을 보장하는 정렬이다. ex) [7,3,2,6,9,7] 배열에는 7이 두 개 존재한다. 첫번째는 7(1), 두번째를 7(2)라고 하였을 때 안정적인 정렬은 이 순서를 항상 보장한다. 시간복잡도 : O(nlogn) 계수 정렬(count sort)계수 정렬은 갑들을 비교하지 않기 때문에 O(k+n)시간 안에 수행된다. 숫자에 대해서만 동작하며 특정 범위가 주어져야 한다는 한계가 있다. 배열의 각 항목의 등장 횟수를 센다. 해당 등장 횟수를 사용해 새로운 배열을 생성할 수 있다. 계수 정렬은 항목들을 교환하지 않고도 자료를 정렬한다. 제한된 범위의 정수를 정렬할 때는 계수 정렬이 가장 빠른 정렬이다. 1234567891011121314151617181920function countSort(array) &#123; var hash = &#123;&#125;, countArr = []; for (var i = 0; i &lt; array.length; i++) &#123; if (!hash[array[i]]) &#123; hash[array[i]] = 1; &#125; else &#123; hash[array[i]]++; &#125; &#125; for (var key in hash) &#123; // 항목이 몇개가 되든 해당 항목을 배열에 추가한다. for (var i = 0; i &lt; hash[key]; i++) &#123; countArr.push(parseInt(key)); &#125; &#125; return countArr;&#125; 자바스크립트 내장 정렬자바스크립트네는 배열 객체에 사용 가능한 내장 메소드인 sort()가 있다. sort()는 항목들을 오름차순으로 정렬한다. 필요한 경우 sort() 함수 호출 시 비교 함수를 sort() 함수의 매개변수로 전달할 수 있다. 기본 비교 함수는 배열을 알파벳 순으로 정렬한다. 따라서 기본 비교 함수는 숫자 자료에 대해서는 제대로 동작하지 않는다. 12var array = [12,4,3,1,2,23,34];array.sort(); // [1,12,2,23,3,34,4] 위 결과가 나오는 이유는 자바스크립트가 항목들을 문자열로 변환한 다음, 항목들을 알파벳 순으로 정렬했기 때문이다. 12345678// 숫자 오름차순 정렬var array = [12,4,3,1,2,23,34];function comparatorNumber(a,b) &#123; return a - b;&#125;array.sort(comparatorNumber); // [1,2,3,4,12,23,34]","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191102_TIL(git 폴더명 변경하기)","slug":"191102-TIL-git-폴더명-변경하기","date":"2019-11-02T14:07:59.000Z","updated":"2019-11-03T14:26:58.729Z","comments":true,"path":"2019/11/02/191102-TIL-git-폴더명-변경하기/","link":"","permalink":"http://progyu.github.io/2019/11/02/191102-TIL-git-폴더명-변경하기/","excerpt":"","text":"git 폴더명 변경하기git을 사용하다보면 가끔 아주 간단한 것이지만 어떻게 해야할지 몰라 잠시 당혹스러울 때가 있다. 오늘은 git으로 관리하는 폴더명을 변경하는 일이 내게 당혹감을 안겨주었다. 이미 GitHub에 push까지 완료된 상태인 폴더의 이름을 어떻게 바꿀 수 있을까? 이 때 OS에서 기본제공하는 이름바꾸기 기능을 이용하여 폴더명이나 파일명을 바꾸어도 git에는 변경사항이 적용되지 않는다. git으로 관리하는 폴더명이나 파일명을 변경하였을 때 git에도 적용하고 싶다면 아래의 git 명령어를 사용하면 된다. 1$ git mv oldName newName 기존 폴더명 파일명을 앞에 입력하고 뒤에 새롭게 바꾸고 싶은 이름을 입력하면 된다. 주의할 점 git은 대소문자를 구분하지 않기때문에 대소문자만 변경하였을 경우에는 에러가 발생할 수 있다. ex) test라는 이름의 폴더를 Test로 변경하는 경우 이 때는 조금 번거롭지만 두단계를 거쳐서 이름을 변경해주면 된다. 12$ git mv test temp$ git mv temp Test","categories":[{"name":"Git","slug":"Git","permalink":"http://progyu.github.io/categories/Git/"}],"tags":[]},{"title":"191029_TIL(Set in JS)","slug":"191029-TIL-JS-in-Set","date":"2019-10-29T11:17:02.000Z","updated":"2019-10-30T05:22:35.256Z","comments":true,"path":"2019/10/29/191029-TIL-JS-in-Set/","link":"","permalink":"http://progyu.github.io/2019/10/29/191029-TIL-JS-in-Set/","excerpt":"","text":"자바스크립트 집합집합 소개집합(set)은 가장 근간이 되는 자료 구조 중 하나다. 집합은 정렬되지 않은 유일한(중복되지 않는) 항목들의 그룹이다. 집합은 상수 시간 연산이 가능한데 그 이유는 집합의 구현이 해시 테이블의 구현을 기초로 하기 때문이다. 자바스크립트에서는 Set(집합)이 기본 지원된다. 1let exampleSet = new Set(); 기본 Set 객체에는 size라는 정수 속성 하나만이 존재한다. 집합 연산집합은 항목이 유일한지 확인하는 데 있어 가장 강력한 도구이다. 삽입집합에는 중복되는 항목들을 추가할 수 없다. 시간복잡도는 O(1)이다. 1234let exampleSet = new Set();exampleSet.add(1); // exampleSet: Set &#123;1&#125;exampleSet.add(1); // exampleSet: Set &#123;1&#125;exampleSet.add(2); // exampleSet: Set &#123;1, 2&#125; 삭제Set.delete는 불리언을 반환한다. 해당 항목이 존재해서 삭제되었다면 true 해당 항목이 존재하지 않으면 false가 반환된다. 1234let exampleSet = new Set();exampleSet.add(1); // exampleSet: Set &#123;1&#125;exampleSet.delete(1); // trueexampleSet.add(2); // exampleSet: Set &#123;2&#125; 배열에서 항목 하나를 삭제하기 위해서는 O(n) 시간이 걸리지만 집합의 경우 O(1)에 항목을 삭제할 수 있다. 포함Set.has는 해당 항목이 집합 내에 존재하는지 확인한다. 시간 복잡도 O(1) 1234let exampleSet = new Set();exampleSet.add(1); // exampleSet: Set &#123;1&#125;exampleSet.has(1); // trueexampleSet.has(2); // false","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191028_TIL(Memory in JS)","slug":"191028-TIL-Array-in-Memory","date":"2019-10-29T02:40:01.000Z","updated":"2019-10-30T05:22:59.523Z","comments":true,"path":"2019/10/29/191028-TIL-Array-in-Memory/","link":"","permalink":"http://progyu.github.io/2019/10/29/191028-TIL-Array-in-Memory/","excerpt":"","text":"자바스크립트 메모리 관리v8 엔진과 같은 최신 자바스크립트 엔진에는 사용하지 않는 변수를 메모리에서 해제하는 가비지 컬렉터(garbage collector)가 있다. DOM 메모리 누수DOM 항목을 가리키는 변수가 이벤트 콜백 외부에 선언된 경우 해당 DOM 항목을 제거하더라도 해당 항목은 여전히 메모리에 남게 된다. 123456789101112131415161718192021222324252627282930&lt;div class=\"one\"&gt;One&lt;/div&gt;&lt;div class=\"two\"&gt;Two&lt;/div&gt;&lt;script&gt; const one - document.querySelector(.'one'); const two - document.querySelector(.'two'); one.addEventListener('click', ()=&gt; &#123; two.remove(); console.log(two); // 삭제 이후에도 출력된다. &#125;) // 해당 DOM이 HTML에서 사라지더라도 해당 DOM이 이벤트 콜백에서 사용됐다면 참조는 남는다. // 다음과 같은 방법으로 DOM 메모리 누수를 쉽게 수정할 수 있다. const one - document.querySelector(.'one'); one.addEventListener('click', ()=&gt; &#123; const two - document.querySelector(.'two'); two.remove(); &#125;) // 이벤트 핸들러를 사용한 뒤 등록해지를 하여도 메모리 누수를 막을 수 있다. const one - document.querySelector(.'one'); one.addEventListener('click', ()=&gt; &#123; const two - document.querySelector(.'two'); two.remove(); &#125;) one.removeEventListener('click');&lt;/script&gt; Window 전역 객체전역 변수를 사용하지 않음으로써 메모리를 절약할 수 있다. 객체 참조 제한하기함수의 객체 전체 범위가 아닌 필요한 범위만 전달해야 하며 특히 전체 객체가 아닌 필요한 속성만 전달하도록 해야한다. 객체가 차지하는 메모리 공간이 매우 클 수도 있기 때문이다. 12345678910111213141516const test = &#123; prop1: 'test', prop2: 'hi'&#125;// 이런 방식으로 매개변수에 전체 객체를 전달하면 안된다.// function printProp1(test) &#123;// console.log(test.prop1);// &#125;// 필요한 속성만 전달해주면 된다.function printProp1(prop1) &#123; console.log(prop1);&#125;printProp1(test.prop1); // 'test'","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191027_TIL(Array in JS)","slug":"191027-TIL-Array-in-JS","date":"2019-10-27T14:25:31.000Z","updated":"2019-10-27T15:27:17.554Z","comments":true,"path":"2019/10/27/191027-TIL-Array-in-JS/","link":"","permalink":"http://progyu.github.io/2019/10/27/191027-TIL-Array-in-JS/","excerpt":"","text":"자바스크립트의 배열삽입.push 메소드를 사용해 새로운 항목을 배열 끝에 추가한다. 시간 복잡도는 O(1)이다. 삭제.pop 메소드를 사용해 마지막으로 추가된 항목을 제거한다. 제거된 항목을 반환한다. 시간 복잡도는 O(1)이다. .shift 메소드는 첫번째 항목을 제거하고 해당 항목을 반환한다. 접근접근 연산은 인덱스를 지정함으로써 수행된다. 시간 복잡도는 O(1)이다. 12const arr = [1,2,3,4];arr[0]; // 1을 반환 반복배열에 반복 접근 하는 여러 방법이 존재한다. 그 방법들 모두 시간 복잡도는 O(n)이다. for(변수; 조건; 수정)123for (let i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; for (in)인덱스를 하나씩 호출하는 방식 12345let array = ['a','b','c'];for (let index in array) &#123; // 배열의 인덱스 console.log(index); // 0,1,2&#125; for( of )12345let array = ['a','b','c'];for (let element in array) &#123; // 배열의 항목 console.log(element); // 'a','b','c'&#125; forEach()forEach는 반복문 밖으로 빠져나오거나 배열 내 특정 항목들을 건너뛸 수 없다. 123let array = ['a','b','c'];array.forEach(element =&gt; &#123; console.log(element)&#125;); // 'a','b','c' 도움 함수.slice(begin, end).slice()는 기존 배열을 수정하지 않고 해당 배열의 일부를 반환한다. 시작 인덱스만 매개변수로 전달하는 경우 끝 인덱스는 해당 배열의 마지막 인덱스 값이 된다. 매개변수로 아무것도 전달하지 않는 경우 .slice()는 배열의 복사본을 반환한다. array.slice() === array 는 false로 평가된다. 그 이유는 해당 배열이 위치한 메모리 주소가 다르기 때문이다. 자바스크립트의 배열은 참조 기반이다. 이는 배열에 신규 변수를 할당한 다음, 해당 신규 변수를 통해 배열을 변경하는 경우 변경 사항이 원래 배열에도 적용 된다는 것을 의미한다. 1234567let array1 = [1,2,3,4];let array2 = array1;array2[0] = 10;array1 // [10,2,3,4]array2 // [10,2,3,4] 새로운 배열을 생성하기 위해서 Array.from()을 사용할 수 있다. 123456789101112131415161718192021222324252627// Array.from() 이용let array1 = [1,2,3,4];let array2 = Array.from(array1);array2[0] = 10;array1 // [1,2,3,4]array2 // [10,2,3,4]// .slice() 이용let array1 = [1,2,3,4];let array2 = array1.slice();array2[0] = 10;console.log(array1); // [1,2,3,4]console.log(array2); // [10,2,3,4]// Spread 연산자 이용let array1 = [1,2,3,4];let array2 = [...array1];array2[0] = 10;console.log(array1); // [1,2,3,4]console.log(array2); // [10,2,3,4] Array.from()의 시간 복잡도는 O(n)이다. .splice(begin, size, element1, element2…).splice() 메소드는 기존 항목을 제거하거나 신규 항목을 추가함으로써 배열의 내용을 반환하고 변경한다. .splice() 메소드는 시작 인덱스, 제거할 항목의 크기, 추가할 신규 항목들의 세 개의 매개변수를 받고 제거된 항목들을 반환한다. 123let array = [1,2,3,4];array.splice(1,2); // [2,3]을 반환. array = [1,4] 123let array = [1,2,3,4];array.splice(1,2,[5,6]); // [2,3]을 반환. array = [1,[5,6],4] .splice() 의 시간 복잡도는 최악의 경우 O(n)이다. .concat()신규 항목을 배열의 맨 뒤에 추가한 다음, 해당 배열을 반환한다. .length 속성.length 속성을 더 작은 크기로 변경하면 배열에서 항목들이 제거된다. 배열의 길이에 제한을 둘 수 있다. 1234let array = [1,2,3,4];array.length = 3;console.log(array); // [1,2,3]; Spread 연산자점 세 개 (…)로 표헌하며 제로 인자가 기대되는 곳에서 인자를 확장하는데 사용할 수 있다. 123let array = [1,2,3,4];Math.max(...array); // 4","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191024_TIL(유사배열객체 와 반복가능한 객체)","slug":"191024-TIL-유사배열객체-와-반복가능한-객체","date":"2019-10-24T11:08:42.000Z","updated":"2019-10-25T07:59:46.687Z","comments":true,"path":"2019/10/24/191024-TIL-유사배열객체-와-반복가능한-객체/","link":"","permalink":"http://progyu.github.io/2019/10/24/191024-TIL-유사배열객체-와-반복가능한-객체/","excerpt":"","text":"유사 배열 객체와 반복 가능한 객체반복 가능한 객체(iterable)의 특징 Symbol.iterator라는 특별한 형태의 메소드가 존재하며 for문 또는 for…of문 등으로 순회가 가능하다. 반복 가능한 객체의 종류 Array Map Set String TypedArray arguments 유사 배열 객체(Array-like-Objects)의 조건 반드시 length 프로퍼티가 필요하다. index는 0부터 시작하여 1씩 증가해야 한다. 유사 배열은 전개 연산자나 for…of와 함께 사용할 수 없다. 1234// 유사 배열 객체 만들기const arrayLike = &#123; 0: 1, 1: 2, 2: 3, length: 3 &#125;;for(let n of arrayLike) &#123; console.log(n) &#125;; // Uncaught TypeError: arrayLike is not iterable 대표적인 유사배열로는 arguments, NodeList 등이 있는데 최신 브라우저 환경에서 iterable이 되었다. 12345function foo (...args) &#123; for(let argument of arguments) &#123; console.log(argument) &#125;;&#125;foo(1,2,3,4,5); // 1,2,3,4,5 String String은 유사배열 객체이면서 반복 가능한 객체이다. 참고 자료MDN_for…of Iterable MDN Iteration protocols","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191023_TIL(프로토타입 메소드 이해하기)","slug":"191023-TIL-프로토타입-메소드-이해하기","date":"2019-10-23T14:01:40.000Z","updated":"2019-10-23T15:57:54.279Z","comments":true,"path":"2019/10/23/191023-TIL-프로토타입-메소드-이해하기/","link":"","permalink":"http://progyu.github.io/2019/10/23/191023-TIL-프로토타입-메소드-이해하기/","excerpt":"","text":"오늘은 친구가 지원한 회사에서 테스트로 나온 문제를 공유해주어서 풀어보았다. 12// 문제. 아래 코드와 같이 \".\"으로 계속해서 이어지는 함수를 작성하시오.add(4).add(5).subtract(3) // 6 …? 처음에 문제를 보았을 때는 이게 뭐지?? 라는 생각이 들었다. 마음을 가다듬고 찬찬히 문제를 들여다보니 프로퍼티 값에 접근하는 방법인 마침표 표기법이 보였다. 아! 객체의 메소드를 이용하는 것이구나라고 단순히 생각하여 자바스크립트에서는 함수도 객체이기 때문에 아래 코드와 같이 함수에서 객체의 메소드를 정의하는 방법을 생각해보았다. 12345678910111213const add = (n) =&gt; &#123; let result = 0; result += n; return &#123; add(n) &#123; result += n; return result; &#125; &#125;;&#125;;const sum = add(4).add(5);sum; // 9 하지만 위 방법으로는 문제에서 요구하는 계속해서 이어지는 함수를 만들 수는 없었다. 그렇다면 어떻게 해야 계속해서 객체의 메소드를 호출할 있을까? 고민을 거듭한 결과 불현듯 프로토 타입 메소드가 떠올랐다. 프로토 타입 메소드란 프로토 타입 체인 상에 존재하는 메소드이다. 자바스크립트는 특정 객체의 메소드에 접근하려고 할 때 해당 객체에 접근하려는 메소드가 없다면 [[Prototype]]이 가리키는 링크를 따라 상위 프로토타입 객체의 메소드를 프로토타입 체인상에서 차례대로 검색한다. 이를 이용하면 아래와 같이 코드를 작성할 수 있다. 12345678910111213let result = 0;Object.prototype.add = function(n) &#123; result += n; return result;&#125;;Object.prototype.subtract = function(n) &#123; result -= n; return result;&#125;;add(4).add(5).subtract(3);// 6 전역변수를 선언한 것이 마음에 들지 않지만 원했던 결과가 제대로 나온다. 위 코드를 해석하기 위해서는 우선 아래의 사실을 인지해야 한다. 프로토타입 체인의 종점, 즉 프로토타입 체인의 최상위 객체는 Object.prototype이며 이 객체의 프로퍼티와 메소드는 모든 객체에게 상속된다. 12// 프로토타입 체인 상 종점에 존재하기 때문에 Object.prototype.__proto__는 null이다.Object.prototype.__proto__ // null 12// 브라우저 환경에서의 전역객체인 window도 프로토타입 체인에 존재하며 따라서Object.prototype의 프로퍼티와 메소드를 상속받아서 사용할 수 있다.window.__proto__.__proto__.__proto__.__proto__ === Object.prototype //true 그런데 add(), subtract() 메소드는 number 타입의 원시값을 반환하는데 어떻게 프로토타입 메소드를 상속 받아서 사용할 수 있는 것일까? string ,number 타입 등의 원시값 뒤에 마침표 표기법이나 대괄호 표기법과 같이 프로퍼티의 값에 접근하는 표기법을 사용하면 순간 임시 객체가 생성되는데 이를 래퍼 객체라고 한다. 즉, 래퍼 객체가 일시적으로 생성되면 프로토타입 메소드를 상속 받아서 사용할 수 있는 것이다. 참고 자료poiemaweb 프로토타입","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191022_TIL(유사배열에 배열 메소드 사용하기)","slug":"191022-TIL-유사배열에-배열-메서드-사용하기","date":"2019-10-22T14:05:25.000Z","updated":"2019-10-23T14:02:07.315Z","comments":true,"path":"2019/10/22/191022-TIL-유사배열에-배열-메서드-사용하기/","link":"","permalink":"http://progyu.github.io/2019/10/22/191022-TIL-유사배열에-배열-메서드-사용하기/","excerpt":"","text":"유사배열에 배열 메소드 사용하기포트폴리오 프로젝트 코드를 리팩토링 하던 중 document.querySelectorAll 을 사용하여 NodeLIst 객체를 받아서 배열 메소드인 map을 사용해야 할 일이 생겨서 아래와 같이 코드를 짰다. 123const imgList = document.querySelectorAll('img');const imgAlt = imgList.map((&#123; alt &#125;) =&gt; alt); 다음과 같은 에러가 발생하였다. 1Uncaught TypeError: imgList.map is not a function 왜 이런 에러가 발생했는지 잠시 생각해보니 너무나도 당연한 것이었다. NodeList는 배열이 아닌 유사 배열 객체이기 때문에 배열 메소드인 map을 사용할 수 없었던 것이다. 그렇다면 배열인지 유사배열인지 어떻게 알 수 있을까? 12345678const array = ['a', 'b', 'c'];const imgList = document.querySelectorAll('img');console.log(Array.isArray(array)); // trueconsole.log(Array.isArray(imgList)); // falseconsole.log(typeof(array)); // objectconsole.log(typeof(imgList)); // object typeof 메소드를 사용하면 배열과 유사배열 모두 object로 나오기 때문에 구별을 할 수 없다. 하지만 Array.isArray 메소드를 사용하면 배열일 때만 true를 return 해주기 때문에 쉽게 구별할 수 있다. 배열과 유사배열을 구분해야 하는 이유는 위에서 언급했다시피 유사배열에 map같은 배열 메소드를 사용하면 에러가 발생하기 때문이다. 하지만, 사실 유사배열에도 배열 메소드를 사용할 수 있는 방법이 있다. 내가 아는 방법은 총 3가지이다. Array객체의 프로토타입에서 해당 배열 메소드를 빌려서 사용하는 방법(call, apply) 12Array.prototype.map.call(imgList, img =&gt; console.log(img));[].map.call(imgList, img =&gt; console.log(img)); Array.from() 메소드 사용 Array.from() 메소드는 유사 배열 객체나 반복 가능한 객체(iterable object)를 얕게 복사하여 새로운 Array 객체를 만든다. 1Array.from(imgList).forEach((img) =&gt; console.log(img)); Spread 연산자를 사용하여 배열 안에서 풀어주는 방법 1[...imgList].map(img =&gt; console.log(img)); 참고 자료MDN-Array.from 제로초-배열과 유사배열","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191021_TIL(Angular8 GitHub Pages)","slug":"191021-TIL-Angular8-GitHub-Pages","date":"2019-10-21T10:05:01.000Z","updated":"2019-10-21T10:51:44.698Z","comments":true,"path":"2019/10/21/191021-TIL-Angular8-GitHub-Pages/","link":"","permalink":"http://progyu.github.io/2019/10/21/191021-TIL-Angular8-GitHub-Pages/","excerpt":"","text":"Angular8 GitHub Pages지난 해커톤 당시 만든 CloneTrello 프로젝트를 GitHub에서 제공하는 정적 페이지에 빌드하기 위해서 구글 신(?)의 힘을 빌리기 위하여 파워 검색을 하였다. 검색 중 아래와 같은 멋진 npm 모듈을 발견! angular-cli-ghpages step1과 step2는 이미 되어있기 때문에 바로 12// step3ng add angular-cli-ghpages 위 명령어로 모듈을 설치하였다. 그리고 바로 stpe4인 아래 명령어 입력 1ng deploy 쉽다쉬워~ stpe5에 설명되어있는 주소 형식을 토대로 접속을 하였지만… 아무 것도 보이지 않는 화면과 404 error만이… 바로 Network 탭으로 가서 확인! 확인해보니 GET 요청을 하는 URL 주소가 이상했다. 1https://progyu.github.io/CloneTrelloAngularWeb/main-es2015.8c7624774e16167cc0dd.js 위와 같이 나의 repository 이름이 포함된 요청을 해야했지만 아래와 같이 나의 github 루트로 요청을 보내고 있었다. 1https://progyu.github.io/main-es2015.8c7624774e16167cc0dd.js 어디서 부터 잘못된 것일까… 다시 처음으로 돌아가서 angular-cli-ghpages 문서를 읽어보았다. 쭉 읽어 내려가던 중 관련있어보이는 옵션 하나를 발견하였다. –base-href ng deploy를 하면 생성되는 dist 폴더에 index.html에 있는&lt;base href=&quot;/&quot;&gt; 태그는 그대로 유지된다고 한다. 정확한 의미를 모르겠어서 dist 폴더에 index.html을 확인하여 보았다. 설명대로 &lt;base href=&quot;/&quot;&gt; 가 그대로 유지된채 있었다. 12345ng deploy// index.html&lt;base href=&quot;/&quot;&gt; 음…? 다시 문서를 읽어가던 중 중요한 힌트를 드디어 발견하였다. “빌드중인 애플리케이션의 기본 URL을 지정합니다.” 오! base 태그에 href속성이 기본URL을 지정하는것이었다. dist 폴더를 생성하고 자동으로 생성되는 gh-pages branch를 아래 명령어로 삭제 1git push origin :gh-pages 그리고 아래와 같이 명령어를 수정 후 입력하였다. 1ng deploy --base-href=\"https://progyu.github.io/CloneTrelloAngularWeb/\" dist폴더에 index.html을 확인하여보니 아래와 같이 내가 원하는대로 설정이 되었다. 12345ng deploy --base-href=\"https://progyu.github.io/CloneTrelloAngularWeb/\"// index.html&lt;base href=\"https://progyu.github.io/CloneTrelloAngularWeb/\"&gt; 기도하는 마음으로 재접속…! 잘 된다!!! 결과물 링크 실행환경","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://progyu.github.io/tags/Angular/"}]},{"title":"191020_TIL(String in JS)","slug":"191020-TIL-String-in-JS","date":"2019-10-20T14:53:59.000Z","updated":"2019-10-20T14:54:31.751Z","comments":true,"path":"2019/10/20/191020-TIL-String-in-JS/","link":"","permalink":"http://progyu.github.io/2019/10/20/191020-TIL-String-in-JS/","excerpt":"","text":"자바스크립트 문자열자바스크립트 문자열 기본자바스크립트의 기본 자료형인 String에는 널리 사용할 수 있는 다양한 문자열 함수가 있다. 문자열 접근.charAt(index)0부터 시작하는 인덱스를 입력 값으로 받고 문자열의 해당 인덱스 위치에 있는 문자를 반환한다. 1'dog'.charAt(1); // 'o' .substring(startIndex, endIndex)지정된 인덱스 사이의 문자들을 반환한다. startIndex에 위치한 문자는 포함하고 endIndex에 위치한 문자는 포함하지 않는다. endIndex를 전달하지 않으면 startIndex부터 문자열의 끝까지 모든 문자 값들을 반환한다. 1234'YouTube'.substring(1,2); // 'o''YouTube'.substring(3,7); // 'Tube''YouTube'.substring(1); // 'ouTube' 문자열 비교자바스크립트에서는 미만 연산자와 초과 연산자를 사용해 문자열을 비교할 수 있다. 문자열 비교 기능은 정렬 알고리즘에서 문자열을 비교할 때 매우 유용하다. 사전 편집순으로 대소를 비교한다. 123456789101112var a = 'a';var b = 'b';console.log(a &lt; b); // truevar a = 'add';var b = 'b';console.log(a &lt; b); // truevar a = 'add';var b = 'ab';console.log(a &lt; b); // false 문자열 검색.indexOf(searchValue[, fromIndex]) 검색하고자 하는 문자열을 매개변수로 받는다. 선택적으로 검색 시작 인덱스를 지정하는 매개변수도 받는다. 문자열의 인덱스를 반환한다. 일치하는 문자열을 발견하지 못한 경우 -1이 반환된다. 대소문자를 구분한다. 12345'Red Dragon'.indexOf('Red'); // returns 0'Red Dragon'.indexOf('RedScale'); // returns -1'Red Dragon'.indexOf('Dragon', 0); // returns 4'Red Dragon'.indexOf('Dragon', 4); // returns 4'Red Dragon'.indexOf('', 9); // returns 9 어떤 문자열 내에 특정 문자열이 존재하는지 확인하기 위해서는 .indexOf()가 -1을 반환하는 확인하면 된다. 12345function existsInString (stringValue, search) &#123; return stringValue.indexOf(search) !== -1;&#125;console.log(existsInString('red','r')); // true;console.log(existsInString('red','b')); // false; 문자열 내에 특정 문자가 몇 번 등장하는지 세는 코드 123456789var str = \"He's my king from this day until his last day\",var count = 0,var pos = str.indexOf('a');while (pos !== -1) &#123; count++; pos = str.indexOf('a', pos + 1);&#125;console.log(count); // 3 startsWith(searchValue), endsWith(searchValue)startsWith는 문자열이 특정 입력으로 시작하면 true를 반환하고 endsWith는 문자열이 특정 입력으로 끝나면 true를 반환한다. 12'Red Dragon'.startsWith('Red'); // true'Red Dragon'.endsWith('Dragon'); // true 문자열 분해.split(separator)하나의 매개변수(분리자)를 입력받아 문자열 배열을 생성한다. 12var test1 = 'chicken,noodle,soup,broth';test1.split(\",\"); // [\"chicken\", \"noodle\", \"soup\", \"broth\"] 빈 분리자를 전달하면 문자열 내 모든 문자로 구성된 배열이 생성된다. 12var test1 = 'chicken';test1.split(\"\"); // [\"c\", \"h\", \"i\", \"c\", \"k\", \"e\", \"n\"] split 함수를 사용하면 문자열을 배열로 변환해 쉽게 항목들을 순회할 수 있다. 문자열 바꾸기.replac(string, replaceString)문자열 변수 내에 특정 문자열을 다른 문자열로 대체한다. 1\"Wizard of Oz\".replace(\"Wizard\",\"Witch\"); // \"Witch of Oz\" 정규 표현식 정규 표현식은 검색 패턴을 정의한 문자열들의 집합이다. 자바스크립트에는 정규 표현식에 사용할 수 있는 기본 객체 RegExp가 포함된다. RegExp의 생성자가 받는 매개변수에는 필수 매개변수인 정규 표현식과 선택 매개변수인 일치 관련 설정이 있다. 일치 관련 설정 i : 대소문자를 구분하지 않고 일치하는 문자열을 검색한다. g: 전역적으로 일치하는 문자열을 검색한다.(멈추지 않고 모든 일치하는 문자열을 찾는다.) m: 다중열 문자열에 대해서도 일치하는 문자열을 검색한다. RegExp의 두 가지 함수 search() : 문자열 내에 일치하는 문자열을 찾는다. 일치하는 첫 번째 문자열을 반환한다. mathc() : 문자열 내에 일치하는 문자열을 찾는다. 모든 일치하는 문자열을 반환한다. String() 객체에있는 RegExp 객체를 인자로 받는 함수 exec() : 문자열 내에 일치하는 문자열을 찾는다. 일치하는 첫 번째 문자열을 반환한다. test() : 문자열 내에 일치하는 문자열을 찾는다. true 또는 false를 반환한다. 기본 정규 표현식 ^ : 문자열/줄의 시작을 나타낸다. \\d : 모든 숫자를 찾는다. [abc] : 괄호 내의 모든 문자를 찾는다. [^abc] : 괄호 내의 문자를 제외한 모든 문자를 찾는다. [0-9] : 괄호 내의 모든 숫자를 찾는다. [^0-9] : 괄호 내의 숫자를 제외한 모든 숫자를 찾는다. (x | y) : x 또는 y를 찾는다. 123var str = \"JavaScript DataStructures\";var n = str.search(/DataStructures/);console.log(n); // 11 자주 사용하는 정규 표현식사용자의 입력이 유효한지 확인할 때 매우 유용하다. 숫자를 포함하는 문자/\\d+/ 12345var reg = /\\d+/;reg.test(\"123\"); // truereg.test(\"33asd\"); // truereg.test(\"5asdasd\"); // truereg.test(\"asdasd\"); // false 숫자만 포함하는 문자/^\\d+$/ 1234var reg = /^\\d+$/;reg.test(\"123\"); // truereg.test(\"123a\"); // falsereg.test(\"11a22\"); // false 부동소수점 문자/^[0-9].[0-9][1-9]+$/ 1234var reg = /^[0-9]*.[0-9]*[1-9]+$/;reg.test(\"12\"); // falsereg.test(\"12.2\"); // truereg.test(\"12.2.3\"); // false 숫자와 알파벳만을 포함하는 문자 /[a-zA-Z0-9]/ 123456var reg = /[a-zA-Z0-9]/;reg.test(\"somethingELSE\"); // truereg.test(\"hello\"); // truereg.test(\"112a\"); // truereg.test(\"112\"); // truereg.test(\"^\"); // false 질의 문자열웹 URL은 대개 경로 찾기나 데이터베이스 질의 목적의 매개변수를 포함한다. 이러한 매개변수를 파싱할 때 정규 표현식은 유용하다. 123456789var uri = 'http://your.domain/product.aspx?category=4&amp;product_id=2140&amp;query=lcd+tv';var queryString = &#123;&#125;;uri.replace( new RegExp (\"([^?=&amp;]+)(=([^&amp;]*))?\" , \"g\" ), function($0, $1, $2, $3) &#123; queryString[$1] = $3; &#125;);console.log('ID: ' + queryString['product_id']); // ID: 2140console.log('Name: ' + queryString['product_name']); // Name: undefinedconsole.log('Category: ' + queryString['category']); // Category: 4 인코딩인코딩은 컴퓨터 과학 분야에서 효율적인 전송 혹은 저장을 위해 문자들을 특수 포맷으로 표현하는 포괄적인 개념이다. 모든 컴퓨터 파일은 특정 구조로 인코딩된다. Base64 인코딩btoa() 함수는 문자열로부터 Base64 인코딩된 ASCII 문자열을 생성한다. 문자열의 문자는 바이트로 취급된다. atob() 함수는 Base64 인코딩을 사용해 인코딩된 문자열을 디코딩한다. 123456//btoa('hello I love learning to computer program');// alternatively:Buffer.from('hello I love learning to computer program').toString('base64')//atob('aGVsbG8gSSBsb3ZlIGxlYXJuaW5nIHRvIGNvbXB1dGVyIHByb2dyYW0');Buffer.from('aGVsbG8gSSBsb3ZlIGxlYXJuaW5nIHRvIGNvbXB1dGVyIHByb2dyYW0', 'base64').toString() 문자열 단축Bit.ly와 같은 단축 URL 생성 원리 데이터 베이스가 URL에 대해 정수 기반 고유 ID를 생성한다. 정수 ID는 문자열로 단축된다. 암호화TLS는 서버와 클라이언트 간에 암호화된 연결을 수립하기 위한 표준 보안 기술이다. 브라우저는 대칭 키 암호화만을 사용한다. 서버는 브라우저에게 자신의 비대칭 공개 키를 전송한다. 브라우저는 현재 세션을 위한 대칭 키를 생성한다. 해당 대칭 키는 서버의 비대칭 공개 키로 암호화된다. 서버는 자신의 비밀 키로 브라우저의 세션을 복호화해 세션 키를 추출한다. 이제 두 시스템 모두 세션 키를 가지고 있고 세션 키를 사용해 자료를 안전하게 전송한다. RSA 암호화가장 널리 사용되는 공개 키 암호화 알고리즘 RSA는 큰 정수의 인수분해 난이도에 기반한 암호화 알고리즘이다. 메시지를 암호화하고 해독하는 과정에는 3단계가 존재한다. 키 생성 : 공개 키(공유됨)와 비밀 키(비밀로 유지됨)가 생성된다. 생성된 키 생성 방법 역시 비밀이어야 한다. 암호화 : 공개 키를 통해 비밀 메시지를 암호화 할 수 있다. 복호화: 비밀 키로만 암호화된 메시지를 복호화 할 수 있다.","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191019_TIL(Number in JS)","slug":"191019-TIL-Number-in-JS","date":"2019-10-19T13:30:35.000Z","updated":"2019-10-19T16:31:07.081Z","comments":true,"path":"2019/10/19/191019-TIL-Number-in-JS/","link":"","permalink":"http://progyu.github.io/2019/10/19/191019-TIL-Number-in-JS/","excerpt":"","text":"자바스크립트의 숫자숫자 체계자바스크립트에서 숫자를 표현할 때 64비트 부동 소수점 표현을 사용한다. 부호 비트(63번째 비트)가 1이면 해당 숫자가 음수다. 다음 여덟개의 비트(63번째부터 52번째 비트)는 지수 값 e를 나타낸다. 마지막으로 나머지 52비트가 분수 값을 나타낸다. 십진분수로 인해 자바스크립트에서 부동소수점 체계가 반올임 오류를 일으킬 수 있다. 12// 0.1과 0.2를 정확하게 표현할 수 없다.0.1 + 0.2 === 0.3 // false 0.1을 부동소수점 숫자로 제대로 표현할 수 없는 이유를 이해하기 위해서는 이진 표기법을 이해해야 한다. 이진 표기법으로 십진수를 표현할 때 무한 개의 수가 필요한 경우가 많다. 자바스크립트 숫자 객체정수 반올림자바스크립트에서 모든 숫자를 나타낼 때 부동소수점을 사용하기 때문에 정수 나눗셈을 소용이 없다. 자바에서는 5/4의 결과로 1이 반환된다. 하지만 자바스크립트에서는 1.25가 반환된다. 자바스크립트에서 정수 나눗셈을 하기 위해서는 다음 중 하나를 사용하면 된다. 1234567891011Math.floor(0.9); // 0Math.floor(1.1); // 1Math.round(0.49); // 0Math.round(0.5); // 1Math.round(2.9); // 3Math.ceil(0.1); // 1Math.ceil(0.9); // 1Math.ceil(21); // 21Math.ceil(21.01); // 22 Number.EPSILONNumber.EPSILON은 두 개의 표현 가능한 숫자 사이의 가장 작은 간격을 반환한다. 이는 부동소수점 근사치를 활용해 분수가 제대로 표현되지 않는 문제를 해결하는데 유용하다. 12345function numberEquals(x, y) &#123; return Math.abs(x - y) &lt; Number.EPSILON;&#125;numberEquals(0.1 + 0.2, 0.3); // true 0.1+0.2와 0.3의 차이는 Number.EPSILON보다 작을 것이다. 최대치Number.MAX_SAFE_INTEGER는 가장 큰 정수를 반환한다. 123Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // trueNumber.MAX_SAFE_INTEGER + 1.111 === Number.MAX_SAFE_INTEGER + 2.022; // false Number.MAX_VALUE는 가장 큰 부동 소수점을 반환한다. 123Number.MAX_VALUE + 1 === Number.MAX_VALUE + 2; // trueNumber.MAX_VALUE + 1.111 === Number.MAX_VALUE + 2.022; // true 최소치Number.MIN_SAFE_INTEGER는 가장 작은 정수를 반환한다. Number.MIN_SAFE_INTEGER는 -9007199254740991이다. 123Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2; // trueNumber.MIN_SAFE_INTEGER - 1.111 === Number.MIN_SAFE_INTEGER - 2.022; // false Number.MIN_VALUE는 가능한 가장 작은 부동소수점 수를 반환한다. Number.MIN_VALUE 는 5e-324이다. Number.MIN_VALUE는 음수가 아니다. Number.MIN_VALUE는 0에 가장 가까운 부동소수점이다. 1Number.MIN_VALUE - 1 == -1; // true 위 코드는 0 - 1 == -1과 비슷하다. 무한Number.MAX_VALUE보다 큰 유일한 것은 Infinity이고 Number.MIN_SAFE_INTEGER보다 작은 유일한 것은 -Infinity이다. 123Infinity &gt; Number.MAX_VALUE; // true-Infinity &lt; Number.MIN_SAFE_INTEGER // true-Infinity -32323323 == -Infinity -1; // true 크기 순서1-Infinity &lt; Number.MIN_SAFE_INTEGER &lt; 0 &lt; Number.MIN_VALUE &lt; Number.MAX_SAFE_INTEGER &lt; Number.MAX_VALUE &lt; Infinity 숫자 알고리즘소수 테스트 2의 배수는 무시해도 된다. 소수 중 2와 3을 제외하고는 6k +- 1의 형태를 지닌다. n이 소수인지 알아보기 위해서는 반복문을 제곱근까지만 확인해보면 된다. n의 제곱근이 소수가 아니면 n은 수학 정의에 의해 소수가 아니기 때문이다. 12345678910111213function isPrime(n) &#123; if (n &lt;= 1) return false; if (n &lt;= 3) return true; if (n % 2 == 0 || n % 3 == 0) return false; for (var i = 5; i * i &lt;= n; i = i + 6) &#123; if (n % i == 0 || n % (i + 2) == 0) return false; &#125; return true;&#125; 시간 복잡도 O(sqrt(n)) 소인수분해소수는 암호화와 해싱의 기반이 된다. 소인수분해는 주어진 숫자를 만들기 위해 어떤 소수들이 곱해져야 하는지 구하는 과정이다. 12345678910111213141516171819function primeFactors(n) &#123; while (n % 2 == 0) &#123; console.log(2); n = n / 2; &#125; for (var i = 3; i * i &lt;= n; i = i + 2) &#123; // While i divides n, print i and divide n while (n % i == 0) &#123; console.log(i); n = n / i; &#125; &#125; if (n &gt; 2) &#123; console.log(n); &#125;&#125; 시간 복잡도 O(sqrt(n)) 무작위 수 생성기Math.random()은 0과 1사이의 부동소수점을 반환한다. 123Math.random() * 100; // 0부터 100까지의 부동소수점Math.random() * 25 + 5; // 5부터 30까지의 부동소수점Math.random() * 10 - 100; // -100부터 -90까지의 부동소수점 무작위 정수를 얻기위해서는 Math.floor(), Math.round(), Math.ceil()을 사용한다. 123Math.floor(Math.random()) * 100;// 0부터 99까지의 정수Math.round(Math.random()) * 25 + 5; // 5부터 30까지의 정수Math.ceil(Math.random()) * 10 - 100; // -100부터 -90까지의 정수","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191018_TIL(Unique parts in JS)","slug":"191018-TIL-Unique-parts-in-JS","date":"2019-10-18T13:05:54.000Z","updated":"2019-10-19T04:09:20.701Z","comments":true,"path":"2019/10/18/191018-TIL-Unique-parts-in-JS/","link":"","permalink":"http://progyu.github.io/2019/10/18/191018-TIL-Unique-parts-in-JS/","excerpt":"","text":"자바스크립트의 독특한 특징자바스크립트는 동적 인터프리터 프로그래밍 언어이다. 자바스크립트의 범위범위(scope)는 자바스크립트 변수에 대한 접근 권한을 정의하는 것이다. 전역 선언: 전역 범위자바스크립트에서는 키워드 없이 변수를 선언하면 암묵적으로 전역 변수를 생성한다. 자바스크립트에서 가장 좋지 않는 선언 방법이므로 사용하지 않도록 하자. var를 사용해 선언하기: 함수 범위변수를 어디에서 선언하든 변수 선언이 함수의 맨 앞으로 이동한 것처럼 동작하는데 이를 변수 호이스팅이라고 한다. let을 활용한 선언: 블록 범위let을 사용해 선언된 변수는 가장 가까운 블록 범위를 갖는다. (즉, 변수가 선언된 {} 내에서 유효하다.) 등가와 형변수형자바스크립트에는 boolean, number, string, undefined, object, null, symbol 과 같은 일곱 개의 자료형이 있다. 특이한 점은 선언만 되고 값이 할당되지 않은 변수에 undefined가 할당된다는 것이다. 참/거짓 확인if문 내에서 참/거짓 확인이 많이 사용된다. 많은 언어들의 경우 if()의 매개변수는 boolean형이어야 하지만 자바스크립트에서는 좀 더 유연하게 사용할 수 있다. 일반적으로 사용되는 표현식 중 false로 평가되는 경우 false 0 빈문자열(‘’, “”) null undefined NaN === vs ==자바스크립트는 스크립트 언어이고 변수 선언 시 변수에 형이 할당되지 않는다. 대신에 코드가 실행될 때 해당 변수의 형이 해석된다. ==는 값만을 확인하다. 반면에 ===는 형과 값 모두 확인한다. 객체12345var o1 = &#123;&#125;;var o2 = &#123;&#125;;o1 == o2 // falseo1 === o2 // false 위 두 객체는 동일한 속성과 값을 지님에도 == 과 ===로 평가 시 동일하지 않다는 결과가 반환된다. 그 이유는 두 객체가 할당된 변수의 메모리 상 주소가 다르기 때문이다. 두 객체의 속성과 값이 같은지 비교하기 위해서는 속성 기반 등가 비교 방식으로 함수를 구현해야 한다. 1234567891011121314151617181920212223function isEquivalent(a, b) &#123; // 속성 이름 배열 var aProps = Object.getOwnPropertyNames(a); var bProps = Object.getOwnPropertyNames(b); // 속성 길이가 다른 경우 두 객체는 다른 객체다. if (aProps.length != bProps.length) &#123; return false; &#125; for (var i = 0; i &lt; aProps.length; i++) &#123; var propName = aProps[i]; // 속성 값이 다른 경우 두 객체는 다른 객체다. if (a[propName] !== b[propName]) &#123; return false; &#125; &#125; // 모든 것이 일치하면 두 객체는 일치한다. return true;&#125;isEquivalent(&#123;'hi':12&#125;,&#123;'hi':12&#125;); // returns true 12345// 'prop2'의 속성 값이 함수이기 때문에 !== 로 평가 시 메모리 상 주소가 다르기 때문에 생각한 바와 같은 결과가 나오지 않는다.var obj1 = &#123;'prop1': 'test','prop2': function ()&#123;&#125; &#125;;var obj2 = &#123;'prop1': 'test','prop2': function ()&#123;&#125; &#125;;isEquivalent(obj1,obj2); // returns false 결론적으로 == 와 ===는 객체의 속성을 기반으로 등가를 비교하고 싶을 때는 적절하지 않다. 객체의 속성을 기반으로 등가 확인을 구현하려면 객체의 각 속성을 확인해야 한다.","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"JavaScript","slug":"Web/JavaScript","permalink":"http://progyu.github.io/categories/Web/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://progyu.github.io/tags/JavaScript/"}]},{"title":"191017_TIL(Big-O)","slug":"191017-TIL-Big-O","date":"2019-10-17T09:44:39.000Z","updated":"2019-10-17T09:54:55.614Z","comments":true,"path":"2019/10/17/191017-TIL-Big-O/","link":"","permalink":"http://progyu.github.io/2019/10/17/191017-TIL-Big-O/","excerpt":"","text":"빅오 표기법빅오 표기법 기초빅오(Big-O) 표기법 시간 및 알고리즘 공간 복잡도 분석을 위해 등장하였다. 빅오(Big-O) 표기법을 배우면 시간(실행 시간)과 공간(사용된 메모리)관점에서 알고리즘 구현을 분석하는 법을 이해할 수 있다. 빅오 표기법에서 n은 입력의 개수를 나타낸다. O(1) : 상수 시간 예) 배열에 있는 항목을 인덱스를 사용해 접근하는 경우 O(n) : 선형 시간 예) 0부터 n-1까지의 숫자를 출력하는 경우 O(n ^ 2): 2차 시간 예) 이중 for문에서 각각 n-1까지 숫자를 출력하는 경우 O(log2n): 로그 시간 예) 2의 1승부터 n승까지의 항목들을 출력하는 경우 빅오 표기법 규칙 계수 법칙 상수를 제거하라! 빅오 표기법의 법칙 중 가장 중요하다. 예) 1234567891011121314151617// f(n) = n인 코드 따라서 시간 복잡도는 O(n)function counter (n) &#123; let count =0; for( let i = 0; i &lt; n; i++) &#123; count += 1; &#125; return count;&#125;// f(n) = 5n인 코드 계수 법칙에 따라 상수를 버리므로 시간 복잡도는 O(n)function counter (n) &#123; let count =0; for( let i = 0; i &lt; 5*n; i++) &#123; count += 1; &#125; return count;&#125; 합의 법칙 빅오를 더하라! 상위 알고리즘의 빅오 표기법은 단순히 해당 상위 알고리즘에 포함되는 두 개의 알고리즘의 합이다. 합의 법칙을 적용한 다음 계수 법칙을 적용해야 한다는 점에 주의해야 한다. 예) 123456789101112// 첫번째 for문은 f(n)=n, 두번째 for문은 f(n)=10n이고, 결괏값은 11n이다.// 계수 법칙을 적용하면 시간복잡도는 O(n)이 된다.function foo(n) &#123; let count = 0; for (let i = 0; i &lt; n; i++) &#123; count += 1; &#125; for (let i = 0; i &lt; 10*n; i++) &#123; count += 1; &#125; return count;&#125; 곱의 법칙 빅오를 곱하라! 중첩 for 루프에 곱의 법칙이 적용된다. 예) 1234567891011// f(n) = 10n * n, 즉, 10n^2이다. 계수 법칙을 적용하면 시간복잡도는 O(n^2)이다.function foo(n) &#123; let count = 0; for (let i = 0; i &lt; n; i++) &#123; count += 1; for (let j = 0; j &lt; 10*n; j++) &#123; count += 1; &#125; &#125; return count;&#125; 다항 법칩 빅오의 k승! f(n)이 k차 다항식이면 f(n)은 O(n^k) 이다. 연습 문제12345678// 다음 코드의 시간 복잡도를 계산하라.function foo(n) &#123; for(let i = 0; i &lt; n; i*2) &#123; console.log(n); &#125; &#125; 답. O(log2n) 로그복잡도다. 주어진 n에 대해 log2n번만 실행된다.","categories":[{"name":"Data-Structures","slug":"Data-Structures","permalink":"http://progyu.github.io/categories/Data-Structures/"}],"tags":[{"name":"Data-Structures","slug":"Data-Structures","permalink":"http://progyu.github.io/tags/Data-Structures/"}]},{"title":"191016_TIL(포트폴리오 코드리팩토링)","slug":"191016-TIL-포트폴리오 코드리팩토링","date":"2019-10-16T14:54:48.000Z","updated":"2019-10-16T15:37:09.180Z","comments":true,"path":"2019/10/16/191016-TIL-포트폴리오 코드리팩토링/","link":"","permalink":"http://progyu.github.io/2019/10/16/191016-TIL-포트폴리오 코드리팩토링/","excerpt":"","text":"포트폴리오 코드 리팩토링12345678910111213141516171819202122232425262728293031323334353637383940414243// 기존 코드// 메가박스const $megaboxWrapper = document.querySelector('.megabox-wrapper');const $megaboxDetail = document.querySelector('.megabox-detail');const $megaboxClose = document.querySelector('.megabox-close');// 트렐로const $trelloWrapper = document.querySelector('.trello-wrapper');const $trelloDetail = document.querySelector('.trello-detail');const $trelloClose = document.querySelector('.trello-close');const openModal = (div) =&gt; &#123; ...&#125;;const closeModal = (div) =&gt; &#123; ...&#125;;// 메가박스 모달 열기$megaboxDetail.onclick = (e) =&gt; &#123; e.preventDefault(); openModal($megaboxWrapper);&#125;;// 메가박스 모달 닫기$megaboxClose.onclick = (e) =&gt; &#123; e.preventDefault(); removeModal($megaboxWrapper);&#125;;// 트렐로 모달 열기$trelloDetail.onclick = (e) =&gt; &#123; e.preventDefault(); openModal($trelloWrapper);&#125;;// 트렐로 모달 닫기$trelloClose.onclick = (e) =&gt; &#123; e.preventDefault(); removeModal($trelloWrapper);&#125;; 1234567891011121314151617181920212223242526272829303132// 개선한 코드const el = (selector) =&gt; document.querySelector(selector);const elList = (selector) =&gt; document.querySelectorAll(selector);const $projectDetailbuttons = elList('.project-detail-btn');const $closeModalbuttons = elList('.modal-close-btn');const $projectWrappers = elList('.project-wrapper');const openModal = (div) =&gt; &#123; ...&#125;;const closeModal = (div) =&gt; &#123; ...&#125;;// 모달 열기$projectDetailbuttons.forEach((button, index) =&gt; &#123; button.onclick = (e) =&gt; &#123; e.preventDefault(); openModal($projectWrappers[index]); &#125;;&#125;);// 모달 닫기$closeModalbuttons.forEach((button, index) =&gt; &#123; button.onclick = (e) =&gt; &#123; e.preventDefault(); removeModal($projectWrappers[index]); &#125;;&#125;); 함수를 이용하여 중복되는 코드인 document.querySelector() 제거 document.querySelector() 매서드를 이용하여 요소를 변수에 하나하나 할당해준던 것을 document.querySelectorAll() 매서드를 이용하여 NodeList 배열 형식으로 하나의 변수에 요소들을 할당 각각의 요소에 동일한 클릭 이벤트를 달아 주던 것을 forEach 매서드를 이용하여 코드의 중복을 제거하고 유지 보수성을 개선","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/tags/TIL/"}]},{"title":"if(kakao) dev 2019 후기","slug":"if kakao-dev-2019-후기","date":"2019-08-31T11:19:43.000Z","updated":"2019-10-16T15:35:35.911Z","comments":true,"path":"2019/08/31/if kakao-dev-2019-후기/","link":"","permalink":"http://progyu.github.io/2019/08/31/if kakao-dev-2019-후기/","excerpt":"","text":"KeyNote 챗봇 주문 중소사업자가 모바일 기반의 주문 서비스를 소비자에게 제공할 수 있다. 카카오 API 현대자동차와 협업하여 소나타에 카카오 인공지능인 kakao i 탑재 아이파크의 신축 아파트에 kakao i 기반의 홈 IOT 환경 구축 카카오 뱅크 단기간에 천만 고객 달성 모바일 퍼스트 전략 ICT 기반의 인터넷 은행만의 장점 살리기 =&gt; 비즈니스 재정의 수준의 재설계 필요 ex) 26주 적금, 모임통장 등 내가 있는 곳이 곧 은행이다. 개발자 역할의 확장이 중요. 프로덕트에 개발자 의견이 반영되어야 한다. 왜 ? =&gt; 개발자는 그 제품에 첫번째 고객이다. 모바일에 대한 다른 접근 + 기술 기반 전략 및 문화 =&gt; 차별화된 새로운 금융 서비스 카카오 맵 국내 최초로 HTML5로 개편. Active X 설치하지 않아도 됨. 3D sky view 연도별로 로드뷰 확인 가능 제주도 지역에서 초정밀(10cm 단위) 버스 위치 확인 서비스 제공 카카오 오픈 API 카카오 메세지 전송 API 카카오톡 플러스 친구 챗봇 API kakao i kakao developers 카카오 기술 공유 tech kakao 리액트: 그것마저 결정해주마리액트로 개발할 때 자주하게 되는 7가지 고민에 대한 해답을 제시하는 방식의 발표였다. 컴포넌트 코드를 일관성 있게 작성하고 싶어요 코딩 컨벤션을 정하세요 eslint 와 prettier를 적극 활용하기를 권장 기존 클래스형 컴포넌트를 훅으로 변경해야 할까요? 리액트 훅을 사용하세요 기존의 함수형 컴포넌트는 상탯값을 가질 수 없는 단점이 있었다 =&gt; 리액트 훅이 나오면서 상탯값을 가질 수 있게 되었다 리액트 훅은 대세라고 생각. 클래스형 컴포넌트가 지상파 TV라면 리액트 훅은 Youtube 만약 새로운 리액트 프로젝트를 시작한다면 리액트훅을 사용해보기를 권장한다 클래스형 컴포넌트의 단점 중복되는 코드가 많다 서로 다른 기능의 코드가 같은 곳에 위치해 있다 간단한 기능을 구현할 때도 코드가 많이 들어간다 서버사이드 렌더링을 해야할까요? 서버사이드 렌더링은 필요할 때만 하세요 서버사이드 렌더링의 장점 검색엔지 최적화(SEO) 사용자 입장에서의 빠른 첫 페이지 렌더링 서버사이드 렌더링의 단점 복잡도 증가 서버 관리 부담 증가 SEO가 필요한 프로젝트라면 선택이 아니라 필수 서버 렌더링이 필요하다면 next.js, 필요하지 않다면 create-react-app을 추천 =&gt; next.js는 이미 SSR 환경이 구축되어 있는 장점이 있다 렌더 함수 안에서 새로운 객체를 생성해도 되나요? 렌더링 성능 최적화는 미리 하지 마세요 리액트에서 가장 중요하면서 cpu를 제일 많이 사용하는 작업은 렌더링 최신 브라우저에서 새로운 객체의 생성은 충분히 빠르다 렌더 함수 호출을 최소화하는 것이 중요 리덕스를 써야하나요? 리덕스 쓰세요 리덕스의 장점 미들 웨어를 기반으로 하는 다수의 유용하 라이브러리 ex) redux-saga 주위에서 타입스크립트 얘기가 많이 들리는데요, 정적 타입을 도입하는게 좋을까요? 타입스크립트 사용하세요 타입스크립트의 장점 연관된 코드는 서로 타입으로 연결되어있어서 코드 간의 이동이 쉬워진다 동적 타입 언어는 IDE 차원에서 지원할 수 있는 기능이 매우 제한적이다. 그에 반해 정적타입어는 지원하는 기능이 많아서 생산성 향상에 크게 도움이 된다. ex) 속성값 리스트업, Auto Import, Rename Symbol css - in - js 방식을 사용하고 싶어요 Styled-components + rebass를 쓰세요 발표자분의 카카오 페이지 리액트 포팅 후기 프론트엔드 기술로 동료들 삶의 질 높여주기 (카카오뱅크 Fun 프로젝트 개발기) 카카오뱅크 고객센터 신분증 검수 업무를 게임처럼 할 수 있게 프로그램 제작 일의 능률향상과 재미를 위해 개발에 착수했지만 고객센터 직원들에게는 기존에 하던 일의 큰 변화가 생기는 것이기 때문에 달가워하지 않음. 서로의 도메인 지식이 달라서 생기는 문제. 회의를 거쳐서 너무 게임같은 느낌은 탈피하고 일의 능률 향상에 초점을 맞추어 개발. 프로그램 제작 전에는 1인 2000건 처리, 제작 후에는 1인 6000건 처리. 일의 능률이 3배 가량 상승 카카오뱅크 오피스 검색 서비스 카카오뱅크 근무자가 늘어나면서 서로의 위치를 찾기 어려워져서 다른 동료들에게 물어물어 어렵게 찾는 장면을 보고 개발에 착수하게 됨 사용자가 계속 이용하고 싶어지는 프로그램의 요건 처음 봤을 때 와! 하는 감탄사가 나와야한다. 심즈라는 3D 게임에서 모티브를 얻어 3D로 제작 Three.js 사용 이용에 재미를 느껴야 한다. 프로그램 내 컴퓨터에서 지렁이 게임이나 지뢰 찾기 등의 또 다른 프로그램을 열 수 있게 제작 모든 사용자에게 자리이동 등의 수정권한 부여 사용이 편리해야 한다. 이름 검색을 하면 자동으로 그 위치로 이동 버튼 한 번 클릭으로 다시 내 위치로 이동 가능 휴가자 정보도 알 수 있음 동료가 곧 서비스이용자이다. 일거리를 찾다보면 할 일은 무궁무진하게 많다. Becoming kakao Krew! (카카오 개발 문화 체험) 온보딩 / 주도적인 일하는 방식 / 다양한 직군과의 협업 / 회고 등 카카오에 입사하면 겪게되는 상황들을 경험하는 체험형 프로그램 카카오 개발 문화 체험에서 가장 먼저 한 체험은 영어 이름 짓기이다. 카카오에서는 어떤 직급을 갖고 있든 서로를 영어이름으로 부른다고 한다. 예를 들어 카카오 CTO가 GD라는 영어이름을 갖고있다면 신입사원도 GD님이나 GD께서와 같은 존칭을 사용하지 않고 GD가~ 이런식으로 아주 수평적인 호칭을 사용한다고 한다. 영어이름을 짓고 나서는 간단하게 자기소개를 하고 카카오 문화와 원칙에 대한 설명을 잠시 듣는다. 카카오 문화 자기주도성 수평 커뮤니케이션 공개/공유 신 / 충 / 헌 =&gt; 신뢰, 충돌, 헌신 카카오 원칙 100 : 0의 원칙 카카오 내부에서는 모든 것을 공개하고 카카오를 벗어나서는 아무것도 공개하지 않는다 1원의 원칙 카카오 크루의 신뢰를 깨뜨릴 수 있다면 그게 1원이라도 문제가 될 수 있다 그 이후에는 실제 카카오 직원들의 근무환경과 유사하게 꾸며놓은 장소로 이동한다. (책상이 수직으로 움직일 수 있어서 서서도 근무할 수 있다.) 이동한 곳에는 노트북이 있고 실제 경주 지진과 같은 재난 상황에서 카카오톡 메신저가 불통이 되었을 때 대처했었던 상황을 재연하여 보여준다. 이런 문제가 발생하였을 때 카카오 직원들은 카카오톡을 만든 회사 답게 카카오 단체 톡방을 이용하기도 하고 자사에서 개발한 팀 커뮤니케이션 프로그램인 agit를 사용한다고 한다. 마지막으로 회고를 하는 시간을 갖고 카카오 문화체험이 어땠는지 10점 만점에 자신이 생각하는 점수를 주고 체험을 마친다. 카카오 개발 문화 체험이라는 타이틀을 달고 있지만 개발 문화를 체험하기에는 시간이 부족하여 아쉬움이 컸다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/tags/TIL/"}]},{"title":"패스트캠퍼스 해커톤 후기(Clone Trello)","slug":"패스트캠퍼스-해커톤-후기-Clone-Trello","date":"2019-07-02T08:00:23.000Z","updated":"2019-07-02T08:12:17.502Z","comments":true,"path":"2019/07/02/패스트캠퍼스-해커톤-후기-Clone-Trello/","link":"","permalink":"http://progyu.github.io/2019/07/02/패스트캠퍼스-해커톤-후기-Clone-Trello/","excerpt":"","text":"0. 사용기술 Angular TypeScript HTML CSS Python Django(Rest Framework) 1. 해커톤 주제이번 해커톤의 주제는 Life changing (인생을 바꾸는 ___ ): 이었다. 2. 팀빌딩이번 해커톤의 팀빌딩 방식은 프론트엔드, 백엔드 , ios 나누지 않고 먼저 주제를 제안하는 제안자가 구글 스프레드시트에 주제를 기입하고 그 주제에 참여를 원하는 사람들이 자유롭게 팀이 되는 형식이었다. 나는 인생을 바꾸는 계획이라는 이름으로 trello를 clone 하자는 제안을 하였고 나를 포함하여 프론트엔드 3명, 백엔드 2명 총 5명이 팀을 이루었다. 3. MVP 선정trello를 clone 하자는 계획을 세웠지만 무턱대고 할 수는 없었다. 순수히 개발을 할 수 있는데 쏟아 부을 수 있는 시간은 대략 30시간 내외 였기 때문에 어느 정도의 기능까지 구현을 할 지 정하고 MVP를 선정하여야 했다. 의논 끝에 회원가입과 다른 사람을 초대하여 같이 board를 사용하는 기능은 시간 내 구현이 어려울 것이라 예상하여 제외하고 trello의 핵심 기능인 List CRUD, Card CRUD, Dialog CRUD , List MOVE, Card MOVE를 MVP로 선정하고 MVP가 완료되면 배경색 변경 기능과 라벨 기능을 추가하기로 하였다. 이렇게 MVP를 선정하고 난 후에 우리는 가장 낯설면서도 핵심 기능중의 하나인 List MOVE, Card MOVE 기능을 구현해보기로 하였다. 의논 끝에 하드코딩으로 구현하기에는 어려운 기능이라고 생각하여 Drag &amp; Drop 기능을 지원해주는 라이브러리가 있는지 찾아보기로 하였다. 팀원 중 한명이 찾아내었고 그 링크는 아래와 같다. Angular material 하지만 위 링크에 있는 예제만으로는 trello의 Drag &amp; Drop 기능을 완벽하게 구현할 수는 없었다. trello의 Drag &amp; Drop 기능은 리스트 간 이동, 리스트 내에서 카드 이동, 리스트 간 카드 이동이 전부 가능하여야 했다. 그래도 우리 팀은 포기하지 않고 위 링크에 나와있는 예제 코드를 이용하여 trello의 Drag &amp; Drop 기능을 구현하는데 성공하였다. (이 기능을 구현하고는 거의 다 한거라고 생각했다…) 4. 디자인, UI 및 레이아웃 &amp;&amp; UX 분석기능을 구현하기에 앞서 디자인, UI 및 레이아웃을 먼저 만들기 시작하였다. trello를 clone 하는 것이기 때문에 별다른 설계없이 trello 웹페이지를 보고 clone하였다. 팀원 중 한명이 여러 사람이 함께 하는 것보다는 한명이 담당하여 빠르게 작업하는 것이 더 좋을 것 같다는 의견을 제시하여서 그렇게 하고 다른 사람들은 그동안 trello 웹페이지를 분석하기로 하였다. 팀원 한명이 디자인 작업을 하는 동안 나머지 팀원과 같이 trello를 분석해보았다. trello를 분석해보면서 느낀 점은 확실히 세계적으로 널리 사용하는 웹 기반의 프로젝트 관리 소프트웨어 답게 처음 접하는 사람들도 쉽게 이용할 수 있는 직관적이고 쉬운 ui, ux를 제공하고 있었다. 그 핵심인 Drag &amp; Drop 기능은 물론이고 사용자가 불필요한 동작을 더 할 필요없이 간결하고 효율적이었다. 예를 들면, 리스트 하나를 만들고 다음 리스트를 만들 시 다른 동작 필요없이 입력하고 enter만 치면 된다. 자동으로 다음 리스트를 만드는 곳으로 커서가 focus 되기 때문이다. 5. 백엔드와의 협업백엔드와 회의를 통해서 어떤 형태의 자료구조로 데이터를 주고 받을 것인지 또, 어떤 기능을 서버와 통신하게 할 것인지 결정하였다. 먼저 자료구조 예시는 아래와 같다. 1234567891011121314151617181920212223242526lists: List[] = [ &#123; \"id\": 62, \"title\": \"todo1\", \"listSort\": 0, \"cards\": [ &#123; \"title\": 62, \"id\": 57, \"cardTitle\": \"잼잼\", \"description\": null, \"comments\": [], \"cardSort\": 0 &#125;, &#123; \"title\": 62, \"id\": 58, \"cardTitle\": \"하이루\", \"description\": null, \"comments\": [], \"cardSort\": 1 &#125; ] &#125; ] 배열 안에 객체 또 그 객체 안에 배열로 이루어진 조금은 복잡한 자료구조이다. 아직 자료구조에 대해서 잘 알지 못해서 이런 구조로 만드는 것이 효율적인지는 판별하기가 어렵다. 위 자료구조에서 가장 까다로웠던 부분은 listSort, cardSort이다. 네임에서도 알 수 있듯이 Drag &amp; Drop 기능을 이용하여 list와 card를 이동하였을 시에 그 index 값을 서버에게 전달하여 이동한 위치를 저장하기 위해 필요한 데이터이다. 사실 처음에는 생각하지 못한 부분이었다. 당황스러웠지만 팀의 협업에 의해 고차함수 map의 두번째 파라미터인 index를 이용하여 데이터를 추출하여 서버에 전달 할 수 있었다. 위 자료구조에 interface는 아래와 같다. 123456789101112131415161718192021export interface List &#123; id: number; title: string; listSort: number; cards: Array&lt;Card&gt;;&#125;export interface Card &#123; title: number; id?: number; cardTitle: string; description: string | null; comments: Array&lt;Comment&gt;; cardSort: number;&#125;export interface Comment &#123; id: number; comment: string; card: number;&#125; 서버와 통신할 기능은 List CRUD, Card CRUD, Dialog CRUD , List MOVE, Card MOVE의 MVP 전부와 추가적으로 가능하다면 배경색 과 라벨까지 하기로 하였다. 6. 기능 구현기능 구현 당시 아직 백엔드에서 작업이 완료되지 않았기 때문에 함수를 이용하여 id와 같이 필요한 데이터를 임의적으로 생성하여 작업을 진행하였다. 기능은 크게 list와 card, dialog로 나눌 수 있었다. 마침 프론트엔드 팀원이 3명이었기 때문에 각자 하나씩 맡아서 진행하였다. 나는 list 파트를 맡아서 진행하였다. list 파트를 진행하면서 가장 어려웠던 점은 사용자의 편의를 생각해서 다양한 이벤트를 생성해야 하고 그 이벤트들을 독립적으로 생성하면 되는 것이 아니라 리스트 간 또, 리스트와 카드 간의 관계를 생각해서 유기적으로 만들어야 한다는 점이었다. 정말 생각한대로 되지 않아서 많은 시행착오를 거듭하였지만 팀원들의 도움에 힘입어 기능 구현에 성공하였다. 해커톤 하면서 가장 큰 깨달음은 문제가 발생하였을시 물론 혼자 문제를 해결해보려고 하는 시도도 필요하지만 너무 불필요하게 오래 문제를 잡고 있는 것보다는 팀원들과의 협력하여 해결하는 것이 더 빠르고 정확하다는 것이다. 우리 팀은 그렇게 막히면 서로에게 물어보고 도움을 청하면서 문제들을 해결하였다. 리스트 기능 구현이 생각보다 일찍 끝나게 되어서 배경색을 변경하는 기능까지 진행하였다. 7. 서버와의 통신해커톤 당일. 서버와의 통신 기능 부분을 제외하고는 상당히 많은 부분의 기능을 구현한 상태로 시작하였다. 서버와의 통신을 위하여 HttpClient 객체와 subscribe를 사용하였다. 백엔드 팀원들이 전해준 api document를 보면서 개발을 진행하였다. api docment를 보면서 개발을 진행한 것은 처음이었는데 직관적이고 이해하기 쉽게 되어있어서 백엔드 팀원들과 많은 대화를 하지 않아도 개발을 진행할 수 있었다. 직접 server에 request를 날려 볼 수도 있고 Request URL, Response Body도 확인해 볼 수 있었다. 서버와의 통신은 생각보다는 순조롭게 이루어졌다. 8. 발표 및 수상발표는 한 팀원에 자원해서 진행하였다. 발표컨셉은 trello를 잘 모르는 사람들에게 실제 trello를 보여준다고 하면서 우리가 만든 trello를 보여주는 것이었다. 발표가 끝나고 여러 사람들에게 물어보니 잘 먹힌듯(?)하다. 다른 팀들의 발표가 모두 끝나고 해커톤 참여자들의 투표와 심사위원님들의 평가결과를 합산하여 수상을 진행하였다. 총 12팀이 참가하였고 3팀이 수상의 영광을 안았다. 다행히 우리 팀도 인생을 바꾸는 작은 기술상을 수상하였다. 해커톤 시작 전 가장 탐나던 상이었는데 수상을 하게 되어서 좋았다. 9. 결과물devpost github","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"hackertone","slug":"hackertone","permalink":"http://progyu.github.io/tags/hackertone/"}]},{"title":"190529_TIL(HTTP Method)","slug":"190529-TIL-HTTP-Method","date":"2019-05-30T11:54:48.000Z","updated":"2019-05-30T16:44:56.721Z","comments":true,"path":"2019/05/30/190529-TIL-HTTP-Method/","link":"","permalink":"http://progyu.github.io/2019/05/30/190529-TIL-HTTP-Method/","excerpt":"","text":"HTTP MethodHTTP Method는 그 종류가 다양하지만 오늘은 가장 많이 쓰이는 5가지 Method에 대해서만 간략하게 정리하려 한다. GET 모든 / 특정 리소스를 조회 payload가 필요 없다. POST 리소스를 생성 payload가 필요하다. PUT 리소스의 전체를 갱신 payload가 필요하다. PATCH 리소스의 일부를 갱신 payload가 필요하다. DELETE 리소스를 삭제 payload가 필요 없다. 위 5가지 Method를 간단한 REST Api 서버와 Postman을 활용하여 테스트를 진행해 보았다. (이미지를 클릭하면 확대 됨) GET Method로 모든 리소스를 조회 GET Method로 특정 리소스를 조회(Id) POST Method로 새로운 리소스를 생성 새로운 리소스가 생성되었음을 확인 DELETE Method로 특정 리소스를 삭제(Id) Id 값을 전달하지 않으면 모든 리소스가 삭제 된다. GET Method로 모든 리소스를 조회 PUT Method로 리소스의 전체를 갱신 리소스 전체가 갱신되었음을 확인 PATCH Method로 리소스의 일부를 갱신(Id) 리소스의 일부가 갱신되었음을 확인","categories":[],"tags":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/tags/TIL/"}]},{"title":"190524_TIL(Hackathon)","slug":"190524-TIL-Hackathon","date":"2019-05-26T14:46:48.000Z","updated":"2019-05-26T16:11:41.586Z","comments":true,"path":"2019/05/26/190524-TIL-Hackathon/","link":"","permalink":"http://progyu.github.io/2019/05/26/190524-TIL-Hackathon/","excerpt":"","text":"5월 24일 (금)패스트캠퍼스에서 주관하는 Hackathon 행사에 참여하였다. 이번 Hackathon 행사는 약 7시간에 걸쳐서 진행되는 아주 짧은 행사였다.(팀원 선정과 주제 선정은 사전에 진행하였다.) 이 행사에 주최 목적은 실제로 어떤 제대로 된 결과물을 내기보다는 다른 사람과 팀을 이루어 같이 어떤 프로그램을 만들어보는데 의의가 있다고 생각한다. 팀원은 나를 포함하여 2인으로 구성되었다. 팀이 구성된 후 주제를 선정하기 위해 팀원과 여러 가지 의견을 나누었다. 처음에는 간단한 게임위주의 주제가 나왔다. 캐치마인드, 벽돌깨기, 포켓몬 그림그리기 등의 의견이 나왔지만 결국에는 수업에 배운 내용을 복습하고 예습하기 좋은 주제를 선정하자는데 의견이 모아져서 “씀” 이라는 어플을 모티브로하여 사용자에게 랜덤한 주제의 글감을 제공하고 사용자가 작성한 글을 입력 받아 저장하는 프로그램을 만들기로 하였다. 주제가 선정된 이후에는 카카오오븐을 활용하여 우리의 구체적인 생각과 디자인 요소를 그려넣어 보았다. 그 이후에는 이미지, 아이콘, 폰트 등의 Resource를 찾아보고 의견을 나누어 선정하였다. 그 이후에는 파트를 나누었는데 팀원이 HTML5와 CSS3를 이용하여 레이아웃 및 디자인 작업을 하고 나는 그동안 따로 Javascript 작업을 진행하다가 팀원의 레이아웃 작업이 끝나면 같이 기능구현의 초점을 맞추기로 하였다. 프로젝트는 HTML5, CSS3, Vanila JavaScript로만 진행을 하였고 다른 툴이나 프레임워크는 사용하지 않았다. git fork을 활용하여 협업을 진행하였고 visual studio code로 작업을 진행하였다. 랜덤한 글감을 제공하기 위해 Math.floor(), Math.random() 메소드를 사용하였고, 랜덤으로 제공된 글감과 사용자가 입력한 글을 객체 형태로 변환하고 사용자가 저장 버튼을 누를 때마다 객체를 배열에 push하였다. 그리고 이 객체가 저장된 배열을 JSON.stringify() 메소드를 이용하여 JSON 문자열 형태로 변환하고 localStorage.setItem() 메소드를 이용하여 localstorage에 저장하였다. 저장된 정보를 불러들 일 때는 localStorage.getItem() 메소드를 이용하였고 JSON.parse()를 이용하여 다시 객체 형태로 변환하였다. 여기까지는 크게 막힘없이 잘 진행이 되었으나 문제는 localStorage에 저장한 정보(랜덤 글감과 사용자가 작성한 글)를 다른 페이지에 액자 형태로 전달하는 것이었다. 해본적이 없는 작업이었기 때문에 앞이 캄캄하고 난감한 기분이 들었다. 우선, 이 문제를 해결하기 위해서 localstorage에 저장한 정보가 다른 페이지에서도 살아있는지 확인하는 작업이 필요했었다. 다행히 다른 페이지로 이동하여도 localstorage 저장한 정보가 살아있었다. 두 번째로는 save 하고 load 할 때 이 전과는 다른 작업이 필요하다는 점을 깨달았다. 여러 방법이 있겠지만 가장 간단하게 든 생각은 다른 js파일을 만들어서 save와 load 할 때 이 전과는 다른 작업을 설정해주는 것이었다. 다행히 이 방법을 통해 기능구현은 가능하였다. 하지만 우리 팀의 MVP(Minimum Viable Product)는 액자 형태로 저장한 이미지를 클릭하였을 때 다시 사용자가 작성한 페이지로 이동하는 것이었는데 시간 관계상 구현하지 못하였다… 그래도 우리 팀원이 영상 능력자(?)여서 내가 발표를 진행할 때 많은 도움이 되었다. 짧은 시간 안에 결과물을 내야하는 압박감 때문에 긴장되는 하루였고 결과물도 아쉬움이 많이 남았지만 분명 매력적인 경험이었다. 다음에 기회가 된다면 다시 한번 참여 해보고싶다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"Hackathon","slug":"Hackathon","permalink":"http://progyu.github.io/tags/Hackathon/"}]},{"title":"190517_TIL(함수)","slug":"190517-TIL-함수","date":"2019-05-17T14:29:13.000Z","updated":"2019-05-17T14:29:58.200Z","comments":true,"path":"2019/05/17/190517-TIL-함수/","link":"","permalink":"http://progyu.github.io/2019/05/17/190517-TIL-함수/","excerpt":"","text":"함수1. 함수란? 수학의 함수는 “입력(input)”을 받아서 “출력(output)”을 내보내는 일련의 과정을 정의한 것이다. 프로그래밍 언어의 함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다. 프로그래밍 언어의 함수도 수학의 함수와 같이 입력을 받아서 출력을 내보낸다. 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다. 함수는 함수 정의(Function Definition)를 통해 생성한다. 함수는 정의만으로 실행되지 않는다. 일련의 과정을 실행하기 위해 필요한 입력, 즉 인수(argument)를 매개변수를 통해 함수에게 전달하면서 함수의 실행을 지시해야 한다. 이를 함수 호출(Function call / invoke)이라 한다. 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 결과를 반환한다. 2. 함수의 사용 이유 함수는 필요할 때 여러 번 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다. 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 3. 함수 리터럴 객체는 객체 리터럴 표기법으로 생성할 수 있다. 함수도 함수 리터럴로 생성할 수 있다. 함수 리터럴은 function 키워드, 함수명, 매개변수 목록, 그리고 함수 몸체로 구성된다. 1234// 변수에 함수 리터럴을 할당var add = function add(x, y) &#123; return x + y;&#125;; 함수명 함수명은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다. 함수명은 함수 몸체 내에서만 참조할 수 있는 식별자다. 함수명은 생략할 수 있다. 함수명이 있는 함수를 기명 함수(named function), 함수명이 없는 함수를 익명 함수(anonymous function)라 한다. 매개변수 목록 0개 이상의 매개변수를 괄호로 감싸고 쉼표로 구분한다. 매개변수에는 인수가 할당된다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 함수 몸체 함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 함수 몸체는 함수 호출에 의해 실행된다. 리터럴 표기법(Literal notation)은 값을 생성하는 가장 기본적인 방법이다. 함수 리터럴도 평가되어 값을 생성하며 이 값은 객체다. 즉, 함수는 객체다. 함수가 객체라는 사실은 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다. 4. 함수 정의함수 선언문 함수 선언문(Function Declaration)은 함수 리터럴 표기법과 형태가 동일하다. 단, 함수 선언문은 함수명을 생략할 수 없다. 함수 선언문은 표현식이 아닌 문으로 해석된다.(변수에 할당 X) 12345function add(x, y) &#123; return x + y;&#125;console.log(add(5, 2)); // 7 함수명은 함수 몸체 내에서만 참조할 수 있는 식별자이다. 그렇다면 외부에서 함수를 참조하고 호출할 때 사용한 add의 정체는 무엇일까?* 함수 객체를 생성하는 시점이 언제인가? 함수 선언문은 실행되어 함수 객체를 생성한다. 이 때 생성된 함수객체를 할당할 변수가 필요하다. 함수 객체를 할당하지 않으면 생성된 함수 객체를 사용할 수 없고 아무도 참조하고 있지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제된다. 자바스크립트 엔진은 함수명과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. 함수는 함수명으로 호출하는 것이 아니라 함수 객체를 가리키는 변수로 호출한다. 즉 , 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수명 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 변수 add인 것이다. 함수 표현식 자바스크립트의 객체는 값처럼 변수에 할당 할 수도 있고 프로퍼티의 값이 될 수도 있으며 배열의 요소가 될 수도 있다. 이러한 객체를 일급 객체라 한다. 자바스크립트의 함수는 일급 객체이다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(Function expression)이라 한다. 123456// 함수 표현식var add = function (x, y) &#123; return x + y;&#125;;console.log(add(8, 2)); // 10 함수 리터럴의 함수명은 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 함수 표현식의 함수 리터럴은 함수명을 생략하는 것이 일반적이다. 함수 생성 시점과 함수 호이스팅123456789101112131415161718// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function // undefined(2,5)// 함수 선언문function add(x, y) &#123; return x + y;&#125;// 함수 표현식var sub = function (x, y) &#123; return x - y;&#125;; 함수 선언문 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르다. 함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 이전에 함수명과 동일한 이름의 변수를 암묵적으로 선언하고 함수 객체를 생성하여 할당한다.즉, 다른 코드가 실행되기 이전에 이미 함수 객체가 생성되고 함수명과 동일한 변수에 함수 객체 할당까지 완료된 상태다. 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(Function Hoisting)이라 한다. 함수 표현식 함수 표현식은 변수 할당문의 값이 함수 리터럴인 문이다. 함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다. 즉, 이 전에 언급한 변수 호이스팅이 일어난다. 함수 표현식의 함수 리터럴은 할당문이 실행되는 시점, 즉 런타임에 평가 되어 함수 객체가 된다. 화살표 함수1234// 화살표 함수const add = (x, y) =&gt; x + y;console.log(add(8, 2)); // 10 ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 모든 상황에서 화살표 함수를 사용할 수 있는 것은 아니다. 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. 5. 매개변수와 인수 함수의 실행을 위해 함수 외부에서 함수 내부로 값을 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 1234567function add(x, y) &#123; return x + y;&#125;var result = add(8, 2);console.log(result); // 10 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 매개변수는 변수와 마찬가지로 undefined로 초기화된 이후 인수가 할당된다. 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다. 인수가 부족한 경우, 매개변수의 값은 undefined이다. 인수가 초과된 경우 인수는 무시되는 것처럼 보인다. 사실은 argument 객체의 프로퍼티로 보관된다. 6. 인수 확인 자바스크립트의 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트는 동적 타입 언어이다. 따라서, 자바스크립트 함수는 매개변수의 타입을 사전에 지정하지 않는다.(인수로 숫자타입이, 문자열 타입 모두 가능하다. ) 7. 매개변수의 개수 매개변수는 순서의 의미가 있다. 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 실수를 유발할 가능성을 높인다. 매개변수의 개수는 적을 수록 좋다. 가장 이상적인 개수는 0개 이며, 최대 3개 이상을 넘지 않을 것을 권장한다. 만약 3개 이상의 매개변수가 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달 받는 것이 좋다. ex) ajax 메소드 8. 외부 상태의 변경과 함수형 프로그래밍1234567891011121314151617181920function changeVal(primitive, obj) &#123; primitive += 100; obj.name = 'Kim';&#125;// 외부 상태var num = 100;var person = &#123; name: 'Lee' &#125;;console.log(num); // 100console.log(person); // &#123;name: \"Lee\"&#125;// 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.changeVal(num, person);// 원시 값은 원본이 훼손되지 않는다.console.log(num); // 100// 객체는 원본이 훼손된다.console.log(person); // &#123;name: \"Kim\"&#125; changeVal 함수는 원시 타입 인수와 객체 타입 인수를 전달 받아 함수 몸체에서 매개변수의 값을 변경한다. 이 때 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경하여도 원본은 훼손되지 않는다. 하지만 객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조값으로 참조한 객체를 변경할 경우 원본이 훼손된다. 함수형 프로그래밍에서는 어떤 외부 상태도 변경시키지 않는 즉, 부수 효과(side-effect)가 없는 함수를 순수 함수(Pure function), 외부 상태를 변경시키는 즉, 부수 효과가 있는 함수를 순수 함수(Impure function)이라 한다. 함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 피하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임이다. 10. 반환문 함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 반환(return) 할 수 있다. 12345678function multiply(x, y) &#123; return x * y; // 값의 반환&#125;// 함수는 반환값으로 평가된다.var result = multiply(6, 3);console.log(result); // 18 함수는 return 키워드를 사용하여 자바스크립트에서 사용 가능한 모든 값을 반환할 수 있다. 함수 호출은 표현식이다. 반환문은 두가지 역할을 한다. 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. 반환문은 return 키워드 뒤에 지정한 값을 반환한다. return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. 함수는 반환문을 생략할 수 있다. 이 때 함수는 함수 몸체의 마지막까지 실행한 후 암묵적으로 undefined를 반환한다. 11. 다양한 함수의 형대즉시실행함수 함수의 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoke Function Expression)라고 한다. 한번만 호출되며 다시 호출할 수는 없다. 즉시 실행 함수는 함수명이 없는 익명 즉시 실행 함수를 사용하는 것이 일반적이다. 1234567891011121314151617181920// 익명 즉시 실행 함수(function () &#123; var a = 3; var b = 5; return a * b;&#125;());var res = (function () &#123; var a = 3; var b = 5; return a * b;&#125;());console.log(res); // 15res = (function (a, b) &#123; return a * b;&#125;(3, 5));console.log(res); // 15 즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸 주어야 한다. 즉시 실행 함수는 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다. 즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있다. 이를 위한 목적으로 즉시 실행 함수를 사용하기도 한다. 재귀 함수 함수가 자기 자신을 호출하는 것을 재귀 호출 (recursive call)이라 한다. 재귀 함수(recursive function)는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다. 재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있다. 재귀 함수는 자신을 무한히 연쇄 호출하므로 호출을 멈출 수 있는 탈줄 조건을 반드시 만들어야 한다. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stack overflow 에러가 발생한다. 재귀 함수는 반복문을 사용하는 것보다 재귀 함수를 사용하는 것이 보다 직관적으로 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다. 중첩 함수 함수 내부에 정의된 함수를 중첩 함수(nested function) 또는 내부 함수(Inner function)이라 한다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수(outer function)를 돕는 헬퍼 함수(helper function)의 역할을 한다. 12345678910111213141516function outer() &#123; var x = 1; // 중첩 함수 function inner() &#123; var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 &#125; inner(); // 중첩 함수의 변수를 참조할 수 없다. console.log(x + y); // ReferenceError: y is not defined&#125;outer(); 콜백 함수 자바스크립트의 함수는 일급 객체이므로 함수의 인수로 함수를 전달할 수 있다. 123456789101112131415161718// 콜백 함수를 전달받는 함수function print(f) &#123; var string = 'Hello'; // 콜백 함수를 전달받는 함수가 콜백 함수의 호출 시기를 결정하고 호출 return f(string);&#125;// print 함수에 콜백 함수를 전달하면서 호출var res1 = print(function (str) &#123; return str.toUpperCase();&#125;);// print 함수에 콜백 함수를 전달하면서 호출var res2 = print(function (str) &#123; return str.toLowerCase();&#125;);console.log(res1, res2); // HELLO hello 위 예제에서 print 함수는 함수를 인수로 전달받는다. print 함수에 인수로 전달된 함수는 print 함수가 호출할 시기를 결정하여 호출한다. 이 때 print 함수에 인수로 전달된 함수를 콜백 함수(Callback function)라고 한다. 콜백함수로서 전달된 함수 리터럴은 콜백 함수를 전달받은 함수가 호출될 때 평가되어 생성된다. 중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수는 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체할 수 없지만 콜백 함수는 함수 외부에서 인수로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 콜백 함수는 비동기 처리를 위해 사용하는 일반적인 패턴으로 주로 이벤트 처리나 Ajax 통신에 사용된다. 12345// 콜백 함수를 사용한 비동기 처리// 1초 후에 메시지를 출력한다.setTimeout(function () &#123; console.log('1초 경과');&#125;, 1000); 뿐만 아니라 콜백 함수는 고차 함수(Higher-order Function)에서도 사용하는 패턴으로 사용 빈도가 매우 높고 중요한 패턴이다. 12345678910111213// 콜백 함수를 사용하는 고차 함수 mapvar res = [1, 2, 3].map(function (item) &#123; return item * 2;&#125;);console.log(res); // [ 2, 4, 6 ]// 콜백 함수를 사용하는 고차 함수 filterres = [1, 2, 3].filter(function (item) &#123; return item &gt; 2;&#125;);console.log(res); // [ 3 ]","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190515_TIL(원시 값과 객체의 비교)","slug":"190515-TIL-원시-값과-객체의-비교","date":"2019-05-16T08:03:33.000Z","updated":"2019-05-16T12:08:06.683Z","comments":true,"path":"2019/05/16/190515-TIL-원시-값과-객체의-비교/","link":"","permalink":"http://progyu.github.io/2019/05/16/190515-TIL-원시-값과-객체의-비교/","excerpt":"","text":"원시 값과 객체의비교1. 원시타입 과 객체 타입데이터 타입의 구분자바스크립트가 제공하는 7가지 데이터 타입(숫자, 문자열, 불리언, null, undefined, symbol, 객체 타입)은 크게 원시 타입(primitive type)과 객체(object / reference type) 타입으로 구분할 수 있다. 원시 타입과 객체 타입의 차이점 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 이에 비해 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 2. 원시 값변경 불가능한 값 원시타입(primitive type)의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이다. 값을 변경할 수 없다는 것은 재할당을 할 수 없다는 의미와는 다르다. 변수는 새로운 값을 재할당 하는 것으로 변수 값을 변경할 수 있다. 변수에 상대 개념인 상수는 재할당이 금지(단 한번의 할당만 허용)된 변수를 말한다. 상수와 변경 불가능한 값은 서로 다른 개념이다. 1234567// const 키워드를 사용해 선언한 상수는 재할당이 금지된다.const o = &#123;&#125;;// 하지만 const 키워드를 사용해 선언한 상수에 할당된 객체는 변경할 수 있다.// 즉, 상수는 재할당이 금지된 변수일 뿐이다.o.a = 1;console.log(o); // &#123;a: 1&#125; 원시 값은 어떤 일이 있어도 불변한다. 이는 값의 신뢰성을 보장한다. 원시 값을 갖는 변수에 새로운 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한다. –&gt; 변수가 참조하던 메모리 주소가 변경된다. 변수가 참조하던 메모리 공간의 주소를 변경한 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문이다. 원시 값이 변경 가능한 값이라면 원시 값 자체를 수정하면 그만이다. 원시 값이 변경 가능한 값이면 값의 변경을 추적하기 어렵게 만들기 때문에 값에 대한 신뢰성을 떨어뜨린다. 불변성을 갖는 원시 값을 값으로 갖는 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다. 문자열과 불변성 원시 값인 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있다. 문자열은 0개 이상인 문자(character)들 집합을 말하며 1개의 문자는 2byte의 메모리 공간에 저장된다. –&gt; 문자열 타입의 값은 몇개의 문자로 이루어졌는지에 따라 필요한 메모리 공간의 크기가 결정된다. ex) 1개의 문자로 이루어진 문자열은 2byte, 10개의 문자로 이루어진 문자열은 20 byte가 필요하다. 자바스크립트의 문자열은 원시 타입이며 변경 불가능하다. 자바스크립트 문자열은 유사 배열이므로 배열과 유사하게 각 문자에 접근할 수 있다. 123456789var str = 'string';// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다.console.log(str[0]); // s// 하지만 문자열은 원시 타입인 값이므로 변경할 수 없다. str[0] = 'S';console.log(str); // string 변수에 새로운 문자열을 재할당하는 것은 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다. 값에 의한 전달 변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가? 12345var foo = 10;var bar = foo;foo = 100;console.log(bar); // ? 위 예제 처럼 변수 bar의 할당한 변수(foo)가 원시 타입의 값(10)을 지녔다면 할당한 변수의 값(10)이 복사(copy) 되어 전달된다. 이를 값에 의한 전달(Pass by value)라 한다. 변수 bar에 foo가 할당 될 때 10이라는 숫자 타입의 값을 갖는다는 점에서는 동일하다. 하지만 변수 foo와 bar의 값 10은 다른 메모리 공간에 저장된 별개의 값이다. 따라서, 변수 foo의 값을 변경하여도 변수 bar의 값에는 어떠한 영향도 주지 않는다. 즉, 값에 의해 전달(Pass by value)된 값은 다른 메모리 공간에 저장된 별개의 값이다. 3. 객체객체 동작 방식 객체는 프로퍼티의 개수가 정해져 있지 않으며 동적으로 추가되고 삭제할 수 있다. 또한, 프로퍼티의 값에도 제약이 없다. 따라서 객체는 원시 값이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다. 원시 값에 비해 상대적으로 큰 메모리를 소비할 수 있기 때문에 원시 값과는 다른 방식으로 동작하도록 디자인되어 있다. 모던 자바스크립트 엔진은 객체의 프로퍼티 값의 위치를 메모리에 저장하기 위해 함수 기반의 유사 딕셔너리 구조(dictionary-like structure)를 사용한다. 변경 가능한 값 객체(참조) 타입의 값, 즉 객체는 변경 가능한 값(mutable value) 이다. 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖는다. 하지만 객체를 할당한 변수는 참조 값(Reference value)를 값으로 갖는다. 참조 값 생성된 메모리 공간의 주고, 그 자체이다. 객체를 할당한 변수가 확보한 메모리 공간에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있다. 이 값을 참조 값이라고 한다. 변수는 이 참조 값을 통해 객체에 접근할 수 있다. 객체를 할당한 변수를 평가하면 메모리에 저장되어 있는 참조 값을 반환하는 것이 아니라 참조 값을 통해 실제 객체에 접근해 그 객체를 반환한다. 객체를 할당한 변수의 경우, “변수는 객체를 참조하고 있다“ 또는 “변수는 객체를 가리키고(point) 있다“ 라고 표현한다. 1234567891011var person = &#123; name: 'Lee'&#125;;// 프로퍼티 값 갱신person.name = 'Kim';// 프로퍼티 동적 추가person.address = 'Seoul';console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다. 이 때, 참조 값은 변경되지 않는다. 참조에 의한 전달 객체는 변경 가능한 값으로 디자인 되어 있다. 이에 따른 부작용(side effect)이 있다. 그것은 원시 값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다. 1234567891011121314151617181920var person = &#123; name: 'Lee'&#125;;// 참조 값을 복사. copy 와 person은 동일한 객체를 참조한다.var copy = person;// copy와 person은 같은 참조 값을 갖는다.console.log(copy === person); // true// copy를 통해 객체를 변경한다.copy.name = 'Kim';// person을 통해 객체를 변경한다.person.address = 'Seoul';// copy와 person은 같은 동일한 가리키고 있다.// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.console.log(person); // &#123;name: \"Kim\", address: \"Seoul\"&#125;console.log(copy); // &#123;name: \"Kim\", address: \"Seoul\"&#125; 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 참조에 의한 전달(Pass by reference)라 한다. 위 예제에서 원본 person 과 사본 copy는 같은 참조 값을 갖고 있기 때문에 동일한 객체({name : ‘Lee’})를 가리키고 있다. 이는 곧 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본(person) 또는 사본(copy) 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다. 12345678910111213var person1 = &#123; name: 'Lee'&#125;;var person2 = &#123; name: 'Lee'&#125;;// 서로 다른 참조 값을 비교한다.console.log(person1 === person2); // ① false// 원시 값인 'Lee'를 비교한다.console.log(person1.name === person2.name); // ② true","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190514_TIL(객체 리터럴)","slug":"190514-TIL-객체-리터럴","date":"2019-05-14T16:07:35.000Z","updated":"2019-05-16T08:03:41.352Z","comments":true,"path":"2019/05/15/190514-TIL-객체-리터럴/","link":"","permalink":"http://progyu.github.io/2019/05/15/190514-TIL-객체-리터럴/","excerpt":"","text":"객체 리터럴1. 객체란? 자바스크립트는 객체(object) 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 타입을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 객체 타입(object / reference type)은 다양한 타입의 값(원시 타입의 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Date structure)이다. 자바스크립트의 객체는 키(key)와 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 프로퍼티의 값으로 자바스크립트에서 사용할 수 있는 모든 값을 사용할 수 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다. 객체는 데이터를 의미하는 프로퍼티와 데이터를 참조하고 조작할 수 있는 동작(behavior)을 의미하는 메소드로 구성된 집합이다. 2. 객체 리터럴에 의한 객체 생성자바스크립트의 객체 생성 방법 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 객체 리터럴 객체 리터럴은 중괄호({…}) 내에 0개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 시점에 객체 리터럴은 해석되고 그 결과 객체가 생성된다. 1234567// 변수에 할당이 이루어지는 시점에 객체 리터럴이 해석되고 그 결과 객체가 생성된다.const person = &#123; name: 'Kim', sayHello: function () &#123; console.log(`Hi! My name is $&#123;this.name&#125;.`); &#125;&#125;; 객체 리터럴의 중괄호는 코드 블록을 의미하지 않는다. 객체 리터럴은 표현식이다. 따라서 객체 리터럴의 중괄호 뒤에는 세미 콜론을 붙인다. 3. 프로퍼티 프로퍼티를 나열할 때는 쉼표(,)로 구분한다. 일반적으로 마지막 프로퍼티 뒤에는 쉼표를 사용하지 않으나 사용해도 상관없다. 프로퍼티 키로는 빈 문자열을 포함하는 모든 문자열 또는 symbol 값을 사용할 수 있다. 프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다. 프로퍼티 키가 반드시 식별자 네이밍 규칙을 따라야 하는 것은 아니다. 하지만 네이밍 규칙을 따랐을 경우에는 따옴표를 생략할 수 있고, 따르지 않은 경우에는 반드시 따옴표를 사용하여야 한다. 123456var person = &#123; first_name: 'jun', // 유효한 이름 'last-name': 'Kim' // 유효하지 않은 이름&#125;;console.log(person); // &#123;first_name: \"jun\", last-name: \"Kim\"&#125; 프로퍼티 값은 자바스크립트에 사용할 수 있는 모든 값을 사용할 수 있다. 프로퍼티 키에 문자열이나 symbol 값 이외의 값을 사용하면 암묵적 타입 변환을 통해 문자열이 된다. 예를 들어, 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. 1234567var foo = &#123; 0: 1, 1: 2, 2: 3&#125;;console.log(foo); // &#123;0: 1, 1: 2, 2: 3&#125; 4. 메소드 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다. 메소드는 객체에 제한되어 있는 함수를 의미한다. 12345678910var circle = &#123; radius: 10, // ← 프로퍼티 // 원의 지름 getDiameter: function () &#123; // ← 메소드 return 2 * this.radius; // this는 circle를 가리킨다. &#125;&#125;;console.log(circle.getDiameter()); // 20 5. 프로퍼티 접근 프로퍼티 값 접근 방법 마침표 표기법(Dot notation) 대괄호 표기법(Bracket notation) 123456789var person = &#123; name: 'Kim'&#125;;// 마침표 표기법에 의한 프로퍼티 접근console.log(person.name); // Kim// 대괄호 표기법에 의한 프로퍼티 접근console.log(person['name']); // Kim 프로퍼티 키가 식별자 네이밍 규칙을 따르지 않는 이름인 경우에는 대괄호 표기법을 사용하여야 한다. 대괄호 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 한다. 6. 프로퍼티 값 갱신 및 동적 생성1234567891011121314151617var person = &#123; name: 'Kim'&#125;;// person객체에 name 프로퍼티가 존재하므로 name 프로퍼티의 값이 갱신된다.person.name = 'Lee';// person객체에 address 프로퍼티가 존재하지 않는다.// 따라서 person객체에 address 프로퍼티가 동적으로 생성되고 값이 할당된다.person.address = 'Busan';console.log(person); // &#123;name: \"Lee\", address: \"Busan\"&#125;// delete 연산자로 address 프로퍼치를 삭제할 수 있다.delete person.address;console.log(person); // &#123;name: \"Lee\"&#125; 7. ES6에서 추가된 객체 리터럴의 확장 기능프로퍼티 축약 표현 객체 리터럴의 프로퍼티는 프로퍼티 키와 프로퍼티 값으로 구성된다. 프로퍼티의 값은 변수에 할당된 값, 즉 식별자 표현식 일 수도 있다. ES6에서 변수명과 프로퍼티 키가 동일한 이름 일 때, 프로퍼티 키를 생략 할 수 있다. 프로퍼티 키는 변수의 이름으로 자동 생성 된다. 123456789101112131415161718// ES5var x = 1, y = 2;var obj = &#123; x: x, y: y&#125;;console.log(obj); // &#123;x: 1, y: 2&#125;// ES6let x = 1, y = 2;// 프로퍼티 축약 표현const obj = &#123; x, y &#125;;console.log(obj); // &#123;x: 1, y: 2&#125; 메소드 축약 표현 ES6에서는 메소드를 선언할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다. 123456789101112131415161718192021// ES5var obj = &#123; name: 'Lee', sayHello: function() &#123; console.log('Hello! ' + this.name); &#125;&#125;;obj.sayHello(); // Hi! Lee// ES6const obj = &#123; name: 'Lee', // 메소드 축약 표현 sayHello() &#123; console.log('Hello!' + this.name); &#125;&#125;;obj.sayHello();// Heollo! Lee","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190513_TIL(rubber-duck)","slug":"190513-TIL-rubber-duck","date":"2019-05-13T11:53:53.000Z","updated":"2019-05-14T08:01:52.437Z","comments":true,"path":"2019/05/13/190513-TIL-rubber-duck/","link":"","permalink":"http://progyu.github.io/2019/05/13/190513-TIL-rubber-duck/","excerpt":"","text":"var 키워드로 선언한 변수의 문제점 같은 스코프 내에서 중복 선언이 허용된다. 블록 레벨 스코프를 지원하지 않는다.(함수 레벨 스코프) 변수 호이스팅 전역 변수의 문제점 암묵적 결합 모든 코드가 전역 변수를 참조하고 변경할 수 있다. 코드의 가독성이 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. 긴 생명 주기 전역 변수의 상태를 변경할 수 있는 시간이 길다. 메모리 리소스를 오랜 기간 소비한다. 스코프 체인 상에서 종점에 존재 변수를 검색할 때 전역 변수가 가장 마지막에 검색 된다. 즉, 전역 변수의 검색 속도가 가장 느리다. 네임 스페이스 오염 파일이 분리되어 있다하여도 하나의 전역 스코프를 공유한다. 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. var, let , const 키워드의 차이점 var 키워드는 선언과 초기화(undefined를 변수에 할당) 가 동시에 이루어진다. (런타임 전) –&gt; 변수 호이스팅 let 과 const 키워드는 런타임 전 선언되고 런타임에 초기화 된다. –&gt; 마치 변수 호이스팅이 일어나지 않는 것처럼 보인다. 1234567891011console.log(varTest); // undefinedvar varTest = 'test1'; console.log(letTest); // Uncaught ReferenceError: Cannot access 'letTest' before initializationlet letTest = 'test2'; console.log(constTest); // Uncaught ReferenceError: Cannot access 'letTest' before initializationconst constTest = 'test3'; var 키워드와 let 키워드는 재할당이 가능하지만 const 키워드는 재할당이 불가능하다. 123const age = 20;age = 30; // Uncaught TypeError: Assignment to constant variable. const 키워드는 반드시 선언과 할당을 하나의 문에 하여야 한다. 123const name; // Uncaught SyntaxError: Missing initializer in const declarationconst name = 'Lee'; // (o)","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190509_TIL(타입 변환과 단축 평가)","slug":"190509-TIL-타입-변환과-단축-평가","date":"2019-05-10T01:58:12.000Z","updated":"2019-05-12T02:02:53.328Z","comments":true,"path":"2019/05/10/190509-TIL-타입-변환과-단축-평가/","link":"","permalink":"http://progyu.github.io/2019/05/10/190509-TIL-타입-변환과-단축-평가/","excerpt":"","text":"타입 변환과 단축 평가1. 타입 변환이란?자바스크립트의 모든 값은 타입이 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting)이라 한다. 동적 타입 언어인 자바스크립트는 개발자의 의도와는 상관없이 자바 스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 암묵적 타입 변환은 변수의 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 피수산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다. 2. 암묵적 타입 변환자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 2.1. 문자열 타입으로 변환11 + '2' // \"12\" 위 예제의 + 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 123456789101112131415// 숫자 타입0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"// 불리언 타입true + '' // \"true\"false + '' // \"false\"// null 타입null + '' // \"null\"// undefined 타입undefined + '' // \"undefined\" 2.2. 숫자 타입으로 변환자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 피연산자를 숫자 타입으로 변환해야 할 문맥은 산술 연산자 뿐만이 아니다. 1'1' &gt; 0 // true 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 123456789101112131415// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN 빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다는 것에 주의하자 2.3. 불리언 타입으로 변환자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다. 아래 값들은 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 false로 평가되는 Falsy 값이다. false undefined null 0, -0 NaN ’’ (빈문자열) 3. 명시적 타입 변환명시적 타입변환의 다양한 방법 래퍼 객체 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법 암묵적 타입 변환을 이용하는 방법 3.1. 문자열 타입으로 변환12345678910111213141516171819202122232425// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // \"1\"// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // \"true\"console.log(String(false)); // \"false\"// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // \"1\"// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // \"true\"console.log((false).toString()); // \"false\"// 3. 문자열 연결 연산자를 이용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // \"1\"// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // \"true\"console.log(false + ''); // \"false\" 3.2. 숫자 타입으로 변환1234567891011121314151617181920212223242526272829303132// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(Number('0')); // 0console.log(Number('-1')); // -1console.log(Number('10.53')); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(Number(true)); // 1console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)// 문자열 타입 =&gt; 숫자 타입console.log(parseInt('0')); // 0console.log(parseInt('-1')); // -1console.log(parseFloat('10.53')); // 10.53// 3. + 단항 연결 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(+'0'); // 0console.log(+'-1'); // -1console.log(+'10.53'); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(+true); // 1console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log('0' * 1); // 0console.log('-1' * 1); // -1console.log('10.53' * 1); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(true * 1); // 1console.log(false * 1); // 0 3.3. 불리언 타입으로 변환1234567891011121314151617181920212223242526272829303132333435// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean(&#123;&#125;)); // trueconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(!!'x'); // trueconsole.log(!!''); // falseconsole.log(!!'false'); // true// 숫자 타입 =&gt; 불리언 타입console.log(!!0); // falseconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // true// null 타입 =&gt; 불리언 타입console.log(!!null); // false// undefined 타입 =&gt; 불리언 타입console.log(!!undefined); // false// 객체 타입 =&gt; 불리언 타입console.log(!!&#123;&#125;); // trueconsole.log(!![]); // true 4. 단축 평가논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 이 두 연산자는 논리 평가를 결정한 피연산자를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다. 단축 평가는 아래의 규칙을 따른다. 단축 평가 표현식 평가 결과 true &#124;&#124; anything true false &#124;&#124; anything anything true &amp;&amp; anything anything false &amp;&amp; anything false","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190508_TIL(제어문)","slug":"190508-TIL-제어문","date":"2019-05-08T12:28:28.000Z","updated":"2019-05-09T04:34:58.208Z","comments":true,"path":"2019/05/08/190508-TIL-제어문/","link":"","permalink":"http://progyu.github.io/2019/05/08/190508-TIL-제어문/","excerpt":"","text":"제어문 제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문은 코드의 실행 순서를 인위적으로 제어할 수 있다. 1. 블록문블록문(Block statement/Compound statement)는 0개 이상의 문을 중괄호롤 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 2. 조건문조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 자바스크립트는 2가지의 조건문 if…else 문과 switch 문을 제공한다. 2.1. if…else 문만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다. 대부분의 if…else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다. 1234567var num = 2;// 0은 false로 취급된다.var kind = num ? (num &gt; 0 ? '양수' : '음수'): '영';console.log(kind); num &gt; 0 ? &#39;양수&#39; : &#39;음수&#39;는 표현식이므로 다른 표현식의 일부가 될 수 있다. 삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나 if…else 문은 값처럼 사용할 수 없다는 차이가 있다. 2.2. switch 문switch문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행 순서를 이동시킨다. switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. break 문을 사용하지 않아 switch 문을 탈출하지 않고 연이어 case문과 default문을 실행하는 것을 폴스루(fall through)라 한다. break 키워드로 구성된 break 문은 코드 블록에서 탈출하는 역할을 한다. break 문을 생략한 폴스루(fall through)가 유용한 경우도 있다. 윤년인 판별해서 2월의 일수를 계산하는 예제 3. 반복문반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. 3.1. for문for문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 123for(변수 선언문 또는 할당문; 조건식; 증감식) &#123; 조건식이 참인 경우 반복 실행될 문;&#125; for문의 실행 변수 선언문은 단, 한번만 실행된다. 조건식의 평가 결과가 true이면 코드 블록을 실행하고, false이면 for문의 실행이 종료된다. 3.2. while문while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다 조건식의 평가 결과가 언제나 참이면 무한루프가 된다. 3.3. do…while문do…while 문은 코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다. 4. break문레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다 중첩된 for문의 내부 for문에서 break 문을 실행하면 내부 for문을 탈출하여 외부 for문으로 진입한다. 내부 for문이 아닌 외부 for문을 탈출하려면 레이블문을 사용한다. ※ 레이블 문 반복문에 레이블을 붙이고, break나 continue 구문을 사용해 반복문의 어느 위치에서 작업을 멈추고 어느 위치에서 다시 수행할지를 알려줄 수 있다. 레이블문은 프로그램의 실행 순서를 제어하기 위해 사용한다. switch문의 case문과 default 문도 레이블 문이다. break는 모든 레이블 구문에서 사용될 수 있으며, continue는 반복 레이블 구문에서만 사용할 수 있다. 중첩된 for문을 외부로 탈출할 때 유용하지만 그 외의 경우 레이블 문은 일반적으로 권장하지 않는다.(가독성이 나빠지고 오류 발생 가능성이 높아진다.) 123456789101112var i, j;loop1:for (i = 0; i &lt; 3; i++) &#123; //첫번째 for문은 \"loop1\" 레이블 loop2: for (j = 0; j &lt; 3; j++) &#123; //두번째 for문은 \"loop2\" 레이블 if (i === 1 &amp;&amp; j === 1) &#123; continue loop1; &#125; console.log('i = ' + i + ', j = ' + j); &#125;&#125; 5. contionue문continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. 1234567// continue 문을 사용하면 if 문 밖에 코드를 작성할 수 있다.for (var i= 0; i &lt; string.length; i++) &#123; if (string[i] !== search) continue; count++;&#125; 참고자료 poiemaweb","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"[CodeWars] Consecutive strings","slug":"CodeWars-Consecutive-strings","date":"2019-05-07T12:15:51.000Z","updated":"2019-05-07T12:19:41.784Z","comments":true,"path":"2019/05/07/CodeWars-Consecutive-strings/","link":"","permalink":"http://progyu.github.io/2019/05/07/CodeWars-Consecutive-strings/","excerpt":"","text":"Consecutive strings 12345678910111213141516function longestConsec(strArr, k) &#123; const n = strArr.length; let currentLongStr = ''; if (n === 0 || k &gt; n || k &lt;= 0) &#123; return ''; &#125; for (let i = 0; i &lt; n; i++) &#123; const loopStr = strArr.slice(i, k + i).join(''); if (loopStr.length &gt; currentLongStr.length) &#123; currentLongStr = loopStr; &#125; &#125; return currentLongStr;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"http://progyu.github.io/categories/Algorithms/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://progyu.github.io/tags/algorithms/"}]},{"title":"190503_TIL(연산자)","slug":"190503-TIL-연산자","date":"2019-05-04T13:48:41.000Z","updated":"2019-05-07T12:17:47.154Z","comments":true,"path":"2019/05/04/190503-TIL-연산자/","link":"","permalink":"http://progyu.github.io/2019/05/04/190503-TIL-연산자/","excerpt":"","text":"연산자 표현식과 연산자표현식 표현식은 하나의 값으로 평가될 수 있는 문(expression statement)이다. 표현식은 리터럴 표현식, 식별자 표현식, 연산자 표현식, 함수/ 메소드 호출 표현식 등으로 나누어 볼 수 있다. 표현식은 결국 하나의 값이 되므로 표현식과 표현식이 평가되어 생성된 값은 동등한 관계, 즉 동치(Equivalent)이다. –&gt; 표현식을 값처럼 사용할 수 있다. (값이 위치할 수 있는 자리에 표현식도 위치할 수 있다.) 1234var score = 80;// 표현식 score + 10은 식별자 표현식과 숫자 리터럴 그리고 연산자의 조합으로 구성되어 있다.console.log(score + 10); // 90 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어 낼 수 있다. 문과 표현식 문(statement)은 하나 이상의 표현식과 키워드의 조합으로 구성된 자바스크립트 엔진에게 내리는 명령이다. 문은 선언문, 표현식 문, 조건문 , 반복문 등으로 구분할 수 있다. 자바스크립트의 모든 코드는 문 또는 표현식이다. 표현식은 문을 구성하는 구(phrase)과 같은 요소이다. 표현식은 그 자체로 문이 될 수도 있다. 표현식의 역할은 값을 생성하는 것이다. 문의 역할은 표현식으로 생성한 값을 사용해 자바스크립트 엔진에게 명령을 내리는 것이다. 표현식인 문과 표현식이 아닌 문 표현식인 문은 값으로 평가될 수 있는 문 , 표현식이 아닌 문은 값으로 평가될 수 없는 문이다, 표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다. 표현식이 아닌 문은 값으로 평가될 수 없으므로 변수에 할당할 수 없다. 12345678910// 변수 선언문은 표현식이 아닌 문이다.var a;// 할당문 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.a = 10;// 표현식이 아닌 문은 값처럼 사용할 수 없다.var foo = var a; // SyntaxError: Unexpected token var 크롬 브라우저 console 창에서 표현식이 아닌 문은 언제나 undefined를 출력한다. 이를 완료 값(Completion value)이라 한다. 연산자란? 연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입 연산(Operation) 등을 수행해 하나의 값을 만든다. 연산의 대상을 피연산자(Operand)라 한다. 피연산자가 “값” 이라는 명사의 역할을 한다면 연산자는 “피연산자를 연산하여 새로운 값을 만든다” 라는 동사의 역할을 한다고 볼 수 있다. 산술 연산자 산술 연산자(Arithmetic Operator)는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우 NaN을 반환한다. 이항 산술 연산자 이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 이항 산술 연산자 의미 부수효과 + 덧셈 X - 뻴셈 X * 곱셈 X / 나눗셈 X % 나머지 X 단항 산술 연산자 단항 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 증가/감소(++ / –) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 단항 산술 연산자 의미 부수 효과 ++ 증가 O – 감소 O + 효과x X - 양수, 음수 변환 X 증가 / 감소(++ / –) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/ 감소 연산자는 먼저 피연산자의 값을 증가 / 감소 시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 휘위 증가/ 감소 연산자는 먼저 다른 연산을 수행 후, 피연산자의 값을 증가 / 감소시킨다. 123456789var x = 5, result;// 선할당 후증가result = x++;console.log(result, x); // 5 6// 선증가 후할당result = ++x;cosole.log(result, x); // 7 7 + 단항 연산자는 숫자 타입이 아닌 피연산자를 숫자 타입으로 변환하여 반환한다. 주의할 점은 피연산자 자체를 변경하는 것이 아니라 숫자 타입으로 변환한 값을 생성해서 반환하는 것이다. 12345var x = '10';console.log(x); // 10console.log(+x); // \"10\" 문자열 연결 연산자 + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 123456789101112131415161718// 문자열 연결 연산자console.log('1' + 2); // '12'// 산술 연산자console.log(1 + 2); // 3// true는 1로 타입 변환된다.console.log(1 + true); // 2// false는 0으로 타입 변환된다.console.log(1 + false); // 1// null는 0으로 타입 변환된다.console.log(1 + null); // 1// undefined는 숫자로 타입 변환되지 않는다.console.log(+undefined); // NaNconsole.log(1 + undefined); // NaN 위 예제에서 1 + true 를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 할당 연산자 할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. 할당 연산자 사례 동일 표현 부수 효과 = x = 10 x = 10 O += x += 10 x = x +10 O -= x -= 10 x = x - 10 O *= x *= 5 x = x * 10 O /= x /= 5 x = x / 5 O %= x %= 5 x = x% 5 O 할당 연산은 하나의 값으로 평가되는 표현식이다. 따라서, 할당 연산 표현식을 다른 변수에 할당할 수도 있다. 비교 연산자 비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다. 동등 / 일치 비교 연산자 비교 연산자 의미 사례 설명 == 동등 비교 x == y x와 y의 값이 같음 === 일치 비교 x === y x와 y의 값과 타입이 같음 != 부동등 비교 x != y x와 y의 값이 다름 !== 불일치 비교 x !== y x와 y의 값과 타입이 다름 동등 비교(==) 연산자는 피연산자를 비교할 때 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값을 갖는지 비교한다. 1console.log(10 == '10'); // true 동등 비교(==) 연산자는 예측하기 어려운 결과를 만들어 내기 때문에 가급적 사용을 지양하고 일치 비교(===) 연산자를 사용하는 것을 추천한다. 다만, 일치 비교 (===) 연산자에서도 두 가지 주의해야 할 점이 있다. 1234567891011// NaN은 자신과 일치하지 않는 유일한 값이다.console.log(NaN === NaN); // false// 숫자가 NaN 인지 조사하려면 빌트인 함수 isNaN을 사용// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.console.log(0 === -0); // trueconsole.log(0 == -0); // true 대소 관계 비교 연산자12345// 대소 관계 비교console.log(7 &gt; 0); // trueconsole.log(7 &gt; 7); // falseconsole.log(7 &gt;= 7); // trueconsole.log(7 &lt;= 7); // true 삼항 조건 연산자 삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 1조건식 ? 조건식이 true 일 때 반환할 값 : 조건식이 false 일 때 반환할 값 ? 앞의 첫 번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 조건식의 평가 결과과 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 123456var x = 10;// 10 % 2는 0 이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 삼항 조건 연산자는 if…else문을 사용해도 동일한 처리를 할 수 있다. if…else문 과 삼항 조건 연산자의 차이점은 if…else문은 표현식이 아닌 문이고삼항 조건 연산자는 값으로 평가할 수 있는 표현식인 문이라는 것이다. 즉, 삼항 조건 연산자는 값으로 사용할 수 있고 다른 표현식의 일부가 될 수 있다. 논리 연산자 논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. 논리 부정(!) 연산자는 언제나 불리언 값을 반환하지만 논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자의 연산 결과는 불리언 값이 아닐 수도 있다. 논리 연산자 의미 부수효과 &#124;&#124; 논리합(OR) X &amp;&amp; 논리곱(AND) X ! 부정(NOT) X 논리합(||) 연산자는 피연산자 둘 중 하나만 true 값이면 true를 반환하고 논리곱(&amp;&amp;) 연산자는 피연산자 둘 모두 true인 경우에만 true를 반환한다. 부정(!) 연산자는 논리 연산 결과를 반대로 반환한다. 쉼표 연산자 쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 123var a, b, c;a = 1, b = 2, c = 3; // 3 그룹 연산자 그룹 연산자 (…)는 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다. 1234console.log(10 / 2 + 3); // 8// 그룹 연산자를 사용하여 우선 순위 조절console.log(10 / (2 + 3)); // 2 typeof 연산자 typeof 연산자는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 일치하지는 않는다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. null을 반환하는 경우는 없다. 12345678910typeof '' // \"string\"typeof 1 // \"number\"typeof NaN // \"number\"typeof true // \"boolean\"typeof undefined // \"undefined\"typeof Symbol() // \"symbol\"typeof null // \"object\"typeof [] // \"object\"typeof &#123;&#125; // \"object\"typeof function () &#123;&#125; // \"function\" 주의할 점은 typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환한다는 것이다. 따라서, null 타입을 확인할 때는 일치 연산자(===)를 사용하면 된다. 1234var x = null;console.log(typeof x === null); // falseconsole.log(x === null); // true 또 하나 주의할 점은 선언하지 않은 식별자를 typeof 연산자로 연산하면 ReferenceError(참조에러)가 발생하지 않고 “undefined”를 반환한다는 것이다. 12// 식별자 undeclared는 선언한 적이 없다.console.log(typeof undeclared); // undefined 참고자료 poiemaweb","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190502_TIL(데이터타입)","slug":"190502-TIL-데이터타입","date":"2019-05-03T12:30:39.000Z","updated":"2019-05-07T12:17:42.183Z","comments":true,"path":"2019/05/03/190502-TIL-데이터타입/","link":"","permalink":"http://progyu.github.io/2019/05/03/190502-TIL-데이터타입/","excerpt":"","text":"데이터 타입데이터 타입에 의한 값의 해석 데이터 타입(Data Type)은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 컴퓨터는 숫자, 텍스트, 이미지, 동영상 등의 모든 데이터를 2진수로 처리한다. 예를 들어 2진수 0100 0001를 숫자로 해석하면 65이지만 문자로 해석하면 ‘A’이다 컴퓨터는 메모리 공간의 주소에서 읽어 들인 2진수를 각각의 데이터 타입으로 인식하고 해석한다. 데이터 타입이 필요한 이유 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 값(value) 더 이상 평가할 수 없는 하나의 표현식 10 + 20은 표현식이다. 평가를 거쳐서 30이라는 값이 된다. 표현식 –&gt; 하나의 값으로 평가될 수 있는 문(statement) 표현식은 표현식의 일부가 될 수 있다. 리터럴 –&gt; 가장 최소 단위의 표현식, 값을 만드는 방식, 평가되기 이전의 상태 10 + 20 = 30; 10과 20은 리터럴 이지만, 30은 리터럴이 아니다. 리터럴은 메모리의 저장되지 않는다. 리터럴은 표현식의 원소가 될 수 있다. ex) 10 + 20 평가 –&gt; 하나의 값으로 만드는 것. 데이터 타입의 분류 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다. 원시 타입(primitive type) 숫자(number) 타입: 숫자 (정수, 실수) 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참과 거짓 undefined 타입: 선언은 되었지만 값을 할당하지 않은 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 (object/reference type): 객체, 함수, 배열 등 숫자 타입 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식(double-precision 64-bit floating-point format : -(253 -1) ~ 253 -1 사이의 숫자 값)을 따른다. 즉, 모든 수를 실수로 처리하며 정수만을 표현하기 위한 특별한 데이터 타입(integer type)은 없다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다. 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not-a-number) 문자열 타입 기본적으로 작은 따옴표 사용. 특수한 상황에서 백틱(ES6)을 사용한다. 문자열을 따옴표로 감싸는 이유? 문자열의 시작과 끝을 알리기 위해 자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 템플릿 리터럴 (backtick) 문자 `를 사용 ES6 템플릿 리터럴은 일반적인 문자열과 달리 여러 줄에 걸쳐 문자열을 작성할 수 있으며 템플릿 리터럴 내의 모든 공백은 있는 그대로 적용된다. 문자열 인터폴레이션은 ${ … }으로 표현식을 감싼다. 문자열 인터폴레이션 내의 표현식은 문자열로 강제 타입 변환된다. 12345678910111213const template = `템플릿 리터럴은 '작은따옴표(single quotes)'과 \"큰따옴표(double quotes)\"를 혼용할 수 있다.`;// HTML을 다룰 시 굉장히 편하다.const template = `&lt;ul class=\"nav-items\"&gt; &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#news\"&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;`;// 인터폴레이션, 평가한 다음에 문자열화 한다.console.log(`1 + 1 = $&#123;1 + 1&#125;`); // 1 + 1 = 2 참고자료 poiemaweb","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190501_TIL(변수)","slug":"190501-TIL-변수","date":"2019-05-01T12:36:26.000Z","updated":"2019-05-07T12:17:38.092Z","comments":true,"path":"2019/05/01/190501-TIL-변수/","link":"","permalink":"http://progyu.github.io/2019/05/01/190501-TIL-변수/","excerpt":"","text":"변수1. 변수란 무엇인가? 왜 필요한가?변수 하나의 값을 저장할 수 있는 메모리 공간에 붙인 이름 또는 메모리 공간 자체를 말한다. 메모리 주소를 직접 다루지 않아도 값을 저장하거나 참조할 수 있다 재사용할 수 있도록 메모리 공간을 식별할 수 있는 이름을 붙인 것 변수명을 통해 컴퓨터에게 참조를 요청하면 컴퓨터는 변수명과 매핑된 메모리 주소를 통해 메모리 공간에 접근하여 저장된 값을 반환해 준다. 변수에 값을 저장하는 것을 할당(assignment 대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 참조(reference)라고 한다. 변수는 사람의 언어로 기술한 변수명을 통해 저장된 값의 의미를 명확히 할 수 있다. –&gt; 가독성을 높여준다. 질문사항 메모리 주소로 메모리에 직접 접근하는 것이 위험한 일이지만 재사용은 가능한 것 아닌가? 그렇다면 변수는 개발자가 직접적으로 메모리를 제어하는 것이 위험하기 때문에 간접적인 제어가 가능하도록 고안된 것인가??? 식별자 변수명을 식별자라고도 부른다. 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 식별자라는 용어는 변수에만 국한해서 사용하지 않는다. 예를 들어, 변수, 함수, 클래스 등의 이름은 값을 구별할 수 있는 이름이므로 모두 식별자다. 따라서 식별자는 변수명보다는 상위 개념이다. 2. 변수 선언변수 선언 이란? 변수 선언(Variable declaration)이란 변수명(식별자)을 등록하여 자바스크립트 엔진에 변수의 존재를 알려 관리하도록 하는 것을 말한다 변수를 선언할 때는 var, let, const 키워드를 사용한다. let, const 키워드가 도입되기 이전까지 변수를 선언할 수 있는 유일한 키워드인 var은 블록 레벨 스코프(Block-level scope)를 지원하지 않는 점, 중복 선언을 허용하는 점, var 키워드 없이 변수 선언이 가능하다는 단점이 있다. 변수의 값을 할당하지 않으면 메모리 공간이 비어있는 것이 아니라 자바스크립트 엔진에 의해 undefined(원시타입의 값)라는 값이 암묵적으로 할당되어 초기화된다. 자바스크립트 엔진의 변수 선언 2단계 선언 단계(Declaration phase) 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase) 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. 3. 변수 선언의 실행 시점과 변수 호이스팅변수 선언의 실행 시점 변수 선언은 소스 코드가 순차적으로 한줄씩 실행되는 시점(런타임, run-time)이 아니라 그 이전(파싱 타임, parsing-time)에 먼저 실행된다 자바스크립트 엔진은 소스 코드를 한줄씩 순차적으로 실행하기 이전에 먼저 소스 코드 전체를 평가한다. 이때 모든 선언문(변수 선언문, 함수 선언문 등)을 찾아내어 식별자를 등록하고 초기화한다. 그후, 선언문을 제외한 소스 코드를 한줄씩 순차적으로 실행한다. 변수 호이스팅(Variable Hoisting) 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징 호이스팅은 변수 선언 뿐만이 아니라 var, let, const, function, function*, class 키워드를 사용한 모든 선언문에 적용된다. 질문사항 let , const 키워드를 사용하여 변수를 선언하면 마치 호이스팅이 되지 않은 것처럼 ReferenceError(참조에러)가 발생하는데 왜 그런 것인지????? 4. 값의 할당 변수에 값을 할당(assignment 대입, 저장)할 때는 할당 연산자(=)를 사용한다. 변수 선언은 다른 코드가 실행되기 이전, 즉 파싱 타임에 먼저 실행되지만 값의 할당은 코드가 순차적으로 실행되는 시점인 런타임에 실행된다. 따라서, 변수의 호이스팅이 일어나도 값이 할당된 상태가 아닌 선언된 상태로 호이스팅된다. 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당 값을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 할당 값을 저장하는 것에 주의하자. 5. 값의 재할당 현재 변수가 저장하고 있는 값을 버리고 새로운 값을 저장하는 것 처음 값을 할당했을 때와 마찬가지로 새로운 메모리 공간을 확보하고 그 메모리 공간에 값을 저장 변수에 값이 새롭게 재할당되면 이전에 할당된 값은 어떤 변수도 값으로 갖고 있지 않은 불필요한 값이 된라. 이러한 값은 가비지 컬렉터(Garbage Collector)에 의해 메모리에서 자동 해제된다. 자바스크립트와 같은 매니지드 언어는 메모리의 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 담당하고 개발자의 직접적인 메모리 제어를 허용하지 않는다. 참고자료poiemaweb","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190430_TIL(웹 브라우저의 동작)","slug":"190430-TIL-Web-browser-동작원리","date":"2019-05-01T09:49:44.000Z","updated":"2019-05-07T12:17:34.210Z","comments":true,"path":"2019/05/01/190430-TIL-Web-browser-동작원리/","link":"","permalink":"http://progyu.github.io/2019/05/01/190430-TIL-Web-browser-동작원리/","excerpt":"","text":"웹 브라우저의 동작 브라우저의 핵심 기능은 사용자가 참조하고자 하는 웹 페이지를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 표시하는 것이다. 브라우저는 동기(Synchronous)적으로 HTML, CSS, 자바스크립트를 처리한다. 이것은 script 태그의 위치에 따라 블로킹이 발생하여 DOM의 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다. script 태그의 위치에 따른 DOM 객체 head 요소 내부에 script 태그를 위치시키면 HTML 요소가 파싱되어 DOM 객체로 변환되기 이전에 자바스크립트가 실행되기 때문에 아직 변환되지 않은 HTML요소를 참조할 수 없다. 반면에, body 요소의 가장 아래에 script 태그를 위치시키면 이미 HTML 파서가 HTML 요소를 모두 파싱하여 DOM 객체를 생성하였기 때문에 자바스크립트가 DOM 조작 시 에러가 발생하지 않는다. 또한, HTML 요소들이 스크립트 로딩 지연으로 인해 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다. 웹 브라우저의 동작 순서 클라이언트가 서버에게 Request(요청)을 보낸다. 서버가 Response(응답)을 보낸다. 클라이언트가 서버의 응답을 받아서 HTML, CSS, JavaScript, 이미지 등의 파일을 Load한다. 렌더링 엔진의 HTML 파서와 CSS 파서가 HTML, CSS 파일을 파싱(Parsing)한다. 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다. 파싱된 결과를 바탕으로 HTML은 DOM tree, CSS는 CSSOM tree, JavaScript는 syntax tree로 변환한다. syntax tree에서 DOM tree와 CSSOM tree를 제어한다. DOM tree와 CSSOM tree가 렌더 트리로 결합된다. 생성된 렌더 트리를 기반으로 브라우저는 웹 페이지를 표시한다. 참고자료 브라우저의 동작 원리","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190429_TIL(JavaScript 와 ECMAScript의 차이, API란?)","slug":"190429-TIL-JavaScript-와ECMAScript의-차이-web-API란","date":"2019-04-29T12:32:54.000Z","updated":"2019-05-07T12:17:30.125Z","comments":true,"path":"2019/04/29/190429-TIL-JavaScript-와ECMAScript의-차이-web-API란/","link":"","permalink":"http://progyu.github.io/2019/04/29/190429-TIL-JavaScript-와ECMAScript의-차이-web-API란/","excerpt":"","text":"JavaScript와 ECMAScript의 차이 JavaScript는 1995년에 탄생되었다. 이후 자바스크립트의 파편화와 이로인한 크로스 브라우징 이슈가 발생하면서 이를 개선하고자 모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트에 대한 필요성이 대두되었다. 1997년 비영리 표준화 기구인 ECMA 인터내셔널이 자바스크립트 초판(ECMAScript 1)의 명세(specification)를 완성하여 ECMAScript로 명명하였다. ECMAScript는 JavaScript를 기반으로 하는 동시에, JavaScript 역시 ECMAScript를 기반으로 한다 ECMAScript는 스크립트 언어의 표준 명세인 ECMA-262를 말하며 프로그래밍 언어의 타입, 값, 객체와 프로퍼티, 함수, 빌트인 객체 등 핵심 문법(core syntax)을 규정한다 자바스크립트는 일반적으로 ECMAScript를 바탕으로 만들어진 프로그래밍 언어로서의 기본뼈대(core)와 브라우저가 별도 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다. 클라이언트 사이드 Web API는 ECMAScript와는 별도로 World Wide Web Consortium (W3C)에서 별도의 명세로 관리하고 있다. API란?API API(Application Programming Interface, 응용 프로그래밍 인터페이스)는 응용프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻합니다. ※ 인터페이스 어떤 기계 장치 간의 정보를 교환하기 위한 수단이나, 방법 예) TV 와 리모콘은 서로 통신을 하기 위해서 정의된 규격에 의해 어떤 신호를 보낼 수 있도록 만들어진 장치이며, 이러한 신호를 서로 주고 받기 위한 방법을 인터페이스라고 한다. REST 분산 하이퍼미디어 시스템(예: 웹)을 위한 아키텍쳐 스타일 REST는 REpresentational State Transfer라는 용어의 약자로서 2000년도에 로이 필딩 (Roy Fielding)의 박사학위 논문에서 최초로 소개되었습니다. REST의 uniform interface를 지원하는 것은 쉽지 않기 때문에, 많은 서비스가 REST에서 바라는 것을 모두 지원하지 않고 API를 만들게 된다. REST API REST형식의 API 핵심 컨텐츠 및 기능을 외부 사이트에서 활용할 수 있도록 제공되는 인터페이스입니다. HTTP프로토콜로 제공하는 API 클라이언트의 종류가 웹 브라우저, 안드로이드 앱, iOS 앱 등 다양해지면서 이러한 클라이언트들에게 정보를 제공하는 방식을 하나로 일원화시키는 방식 중에 대표적인 방식이 HTTP 프로토콜로 API를 제공하는 것 Web API REST에서 몇가지 규칙을 지키지 않을 경우 Web API 혹은 HTTP API라고 부르기도 한다. web 위에서 동작한다 참고자료자바스크립트란? JavaScript와 ECMAScript의 차이 API란 무엇인가? REST API란? 그런 Rest API로 괜찮은가?","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://progyu.github.io/tags/javascript/"}]},{"title":"190428_TIL(재귀코드 읽는 방법, 새로운 언어 공부법, 기타 내용)","slug":"190428-TIL-재귀코드-읽는-방법-새로운-언어-공부법","date":"2019-04-28T13:16:55.000Z","updated":"2019-04-28T14:50:18.309Z","comments":true,"path":"2019/04/28/190428-TIL-재귀코드-읽는-방법-새로운-언어-공부법/","link":"","permalink":"http://progyu.github.io/2019/04/28/190428-TIL-재귀코드-읽는-방법-새로운-언어-공부법/","excerpt":"","text":"오늘은 책에서 도움이 될만한 내용과 지난주 강사님이 해주신 말씀 중 도움이 될만한 내용을 가볍게 정리해 보려한다. 재귀코드 읽는 방법 기저 조건이 무엇인지 찾는다. 기저 조건을 다룬다는 가정하에 함수를 분석한다. 기저 조건 바로 전 조건을 다룬다는 가정하에 함수를 분석한다. 한 번에 한 조건씩 올라가면서 계속 분석한다. 예시 코드(피보나치 수)12345678def fibonacci(n): if n==1: return 0 elif n==2: return 1 return fibonacci(n-1)+fibonacci(n-2)print(fibonacci(4)) 위 재귀코드에 재귀코드 읽는 방법을 적용해보자. 기저조건이 무엇인지 찾기 함수가 자기 자신을 호출하지 않는 조건인 다음 코드가 기저조건이다. 1234if n==1: return 0elif n==2: return 1 ​ n이 1 또는 2일 때가 기저 조건이다. 기저 조건을 다룬다는 가정하에 함수 분석하기 이제 기저 조건인 fibonacci(1) 과 fibonacci(2)를 처리한다. fibonacci(1) 과 fibonacci(2)을 호출하면 모두 기저 조건이므로 재귀가 일어나지 않고 단순히 if문을 실행하여 0과 1을 반환한다. fibonacci(1) returns 0 fibonacci(2) returns 1 기저 조건 바로 전 조건을 다룬다는 가정하에 함수 분석하기 기저 조건 바로 전 조건은 바로 fibonacci(3) 이다. fibonacci(3)을 호출하면 fibonacci(2)+fibonacci(1)를 반환한다. 이전 분석에서 fibonacci(1) 과 fibonacci(2)가 각각 0 과 1을 반환하는 것을 확인했다. 따라서, fibonacci(3)은 0 + 1, 즉 1을 반환한다. 한 번에 한 조건씩 올라가면서 계속 분석하기 fibonacci(4)를 호출하면, fibonacci(3)+fibonacci(2), 즉 2를 반환하고 마찬가지로 fibonacci(5)를 호출하면 fibonacci(4)+fibonacci(3)이 되어 3을 반환한다. 새로운 언어 공부 방법 자료형 연산자 제어문, 반복문 함수 call by reference, call by value, call by object reference 지원여부 First class function 지원여부 Class Encapsulation 지원여부 Inheritance 지원여부 Virtual function 지원여부 기타내용정리하지는 못하였지만 알아두면 좋을 내용들 아스키 코드와 유니코드 시프트 연산과 2의 거듭제곱 비트마스트 진리표 XOR 진리표 진수변환 실수 클로저 TCP/IP 네트워크 프로세스와 스케쥴링 stack frame namespace(이름공간) 참고자료 class OOP 함수 호출 방식 참고도서 누구나 자료구조와 알고리즘","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190426_TIL(Stack and Queue)","slug":"190426-TIL-Stack-and-Queue","date":"2019-04-26T14:47:31.000Z","updated":"2019-04-27T11:29:14.372Z","comments":true,"path":"2019/04/26/190426-TIL-Stack-and-Queue/","link":"","permalink":"http://progyu.github.io/2019/04/26/190426-TIL-Stack-and-Queue/","excerpt":"","text":"스택과 큐 제약을 갖는 배열 임시 데이터를 처리할 수 있는 간결한 도구 데이터를 순서대로 처리할 수 있으며 필요 없으면 버릴 수 있다. 배열과 연결리스트, 파이썬의 리스트 등으로 구현할 수 있다. 스택(Stack)스택의 세 가지 제약 데이터는 스택의 끝에만 삽입할 수 있다. 데이터는 스택의 끝에서만 읽을 수 있다. 데이터는 스택의 끝에서만 삭제할 수 있다. 스택 쉽게 이해하기 접시 더미 접시의 가장 위를 제외하고는 접시를 추가할 수도 제거할 수도 없다.(스택의 끝을 위(top) 이라고도 부른다.) 게으른 학생 스택 연산을 LIFO(&quot;Last In, First Out&quot;) 이라고 한다. 스택에 푸시된 마지막 항목(가장 최근 항목)이 스택에서 팝 될 첫 번째 항목이라는 의미이다. 교실에 가장 마지막에 들어와서 가장 먼저 나가는 학생과 유사하다. 스택 기본 용어 푸시(push) 스택의 끝(위)에 새 값을 삽입하는 것 팝(pop) 스택의 끝(위)에서 원소를 제거하는 것 큐(Queue)큐의 세 가지 제약 데이터는 큐의 끝에만 삽입할 수 있다 (스택과 동일) 데이터는 큐의 앞에서만 읽을 수 있다. (스택과 정반대) 데이터는 큐의 앞에서만 삭제할 수 있다.(스택과 정반대) 큐 쉽게 이해하기 화장실 앞에 줄서기 큐 연산을 FIFO(&quot;First In, First Out&quot;) 이라고 한다. 큐에 삽입된 첫번째 항목(가장 오래된 항목)이 큐에서 제거 될 첫 번째 항목이라는 의미이다. 줄 맨 앞에 있는 사람(가장 먼저 줄 선 사람)이 가장 먼저 화장실에 들어간다. 큐 기본용어 스택과 다르게 큐의 삽입과 삭제는 표준명칭이 없다. 큐 삽입은 put, add, enqueue 등으로 부른다. 큐 삭제는 get, dequeue 등으로 부른다. 스택 두개를 이용하여 큐 구현하기 LIFO(&quot;Last In, First Out&quot;) –&gt; FIFO(&quot;First In, First Out&quot;) class를 이용하여 구현 이해를 위하여 많은 주석을 달았다. 스택 구현 with python123456789101112131415161718192021222324# adapter patternclass Stack: def __init__(self): # 실제로 데이터가 저장되는 곳 self.container=list() def empty(self): # 비어있지 않은 리스트는 True를 반환, 빈 리스트는 False를 반환 # 리스트가 비어있지 않은 경우 # True를 반환 --&gt; if not true --&gt; if false --&gt; if문을 실행하지 않는다 --&gt; False 반환 # 리스트가 비어 있는 경우 # False를 반환 --&gt; if not False --&gt; if true --&gt; if문을 실행한다 --&gt; True 반환 if not self.container: return True return False def push(self, data): # data를 리스트의 끝에 삽입 self.container.append(data) # 래퍼 함수(wrapper function) -함수를 감싸고 있는 함수, 안에서 다른 함수를 호출. 내장함수 pop() def pop(self): return self.container.pop() 스택 두개를 이용하여 큐 구현 with python12345678910111213141516171819202122232425262728293031class Queue: def __init__(self): # 스택 두개를 생성 self.first=Stack() self.second=Stack() def empty(self): # and # 리스트가 비어있는 경우 True를 반환 # True and True 일 때만, True를 반환 # fitst stack 과 second stack이 모두 비어있는 경우에만 True를 반환한다. if self.first.empty() and self.second.empty(): return True return False def enqueue(self, data): # data를 fitst stack의 끝(위)에 삽입 self.first.push(data) def dequeue(self): if self.empty(): return None # first에서 second로 옮기는 시점 # second stack이 비어있을 때(True를 반환) if self.second.empty(): # first stack이 빌 때까지 while not self.first.empty(): # second stack에 first stack을 pop한 값을 push하여 넣어준다 self.second.push(self.first.pop()) return self.second.pop() 테스트 코드123456789101112131415q=Queue()q.enqueue(1)q.enqueue(2)q.enqueue(3)print(q.dequeue())q.enqueue(4)q.enqueue(5)# fitst stack 과 second stack이 모두 비어있는 경우에만 True를 반환한다.# while not True --&gt; while False --&gt; 반복문을 실행하지 않는다.# fitst stack 과 second stack이 모두 비어있는 경우에만 반복문을 실행하지 않는다.while not q.empty(): print(q.dequeue()) 참고자료 조건문 boolean 위키백과 스택 참고도서 누구나 자료구조와 알고리즘","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190425_TIL(insertion sort)","slug":"190425-TIL-insertion-sort","date":"2019-04-25T11:09:38.000Z","updated":"2019-04-25T12:35:23.390Z","comments":true,"path":"2019/04/25/190425-TIL-insertion-sort/","link":"","permalink":"http://progyu.github.io/2019/04/25/190425-TIL-insertion-sort/","excerpt":"","text":"insertion sort(삽입 정렬)insertion sort(삽입 정렬)이란? 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. 최악의 경우의 삽입 정렬의 시간 복잡도는 O(n^2)로 버블정렬이나 선택 정렬과 같다. 하지만, 선택 정렬의 경우 빅오 표기법에 의해 숨겨진 상수항을 표현하면 정확히는 n^2 / 2 단계로 버블 정렬과 삽입 정렬보다 미세하게 빠르다고도 할 수 있다. 하지만, 실질적으로 최악의경우는 드물게 일어난다. 가장 자주 일어나는 경우가 바로 평균의 경우이다. 선택 정렬의 경우 패스스루를 끝낼 매커니즘이 전혀 없기 때문에 최악부터 평균, 최선의 경우에 이르기까지 모두 n^2 / 2 단계가 걸린다. 이에 반해, 삽입 정렬은 패스스루를 빨리 끝낼 수 있는 메커니즘이 있기 때문에 최악의 경우에는n^2 단계, 평균의 경우에는 n^2 / 2, 최선의 경우에는 n단계가 걸린다. 결론적으로. 어떤 데이터를 다루느냐에 따라 더 적절한 정렬 알고리즘을 적용하는 것이 옳다. 삽입정렬 매커니즘 인덱스 1의 값을 temp 라는 변수에 저장한다. 왼쪽에 정렬되어 있는 리스트의 값(현재는 인덱스 0의 값)과 temp의 값을 비교한다. 리스트의 값 &gt; temp 이면 리스트의 값 오른쪽 원소에 리스트의 값을 저장하고 temp 값을 본래 리스트 값이 있던 인덱스(현재는 인덱스 0)의 삽입한다. temp &gt; 리스트의 값이면 그대로 그 자리에 삽입한다. 인덱스의 값을 1씩 증가시키며 왼쪽의 정렬괸 리스트의 값과 temp 값을 비교하여 위 과정을 반복한다. insertion sort(삽입 정렬) 코드 with python 이해하기 위해 많은 주석을 달면서 진행하였다. 12345678910111213141516171819def insertion_sort(array): for index in range(1, len(array)): position=index # 처음 0번 인덱스는 값이 하나이기 때문에 정렬된 리스트로 취급한다. 이 후 과정이 진행되면서 # 인덱스의 앞부분은 정렬된 리스트가 된다. # temp_value의 인덱스의 값을 임시 저장한다. # temp_value로 저장한 값이 배열 위로 솟구쳐 그 원래 공간이 공백이 된다고 생각하면 쉽다. temp_value=array[index] # position &gt; 0 --&gt; positon의 왼쪽 즉, position -1 과 비교를 하기 때문에 position 값이 배열의 0번 index 까지 갈 필요가 없다. # array[position -1] &gt; temp_value --&gt; 배열의 1번 인덱스(패스스루마다 인덱스가 1씩 증가)의 값을 저장한 임시변수(temp_value) 와 왼쪽 값을 비교 # temp_value 보다 왼쪽 값이 크면 왼쪽 값을 오른쪽(공백)으로 시프트 하고 다음 왼쪽 값과의 비교를 위하여 postion을 -1 감소 시킨다. # 이어서 새 position의 왼쪽 값이 temp_value보다 큰지 확인하고 temp_value보다 작은 값을 찾을 때까지 반복한다. while position &gt; 0 and array[position -1] &gt; temp_value: array[position]=array[position -1] position=position -1 # 안쪽 while문이 끝나면 temp_value의 값을 공백에 삽입한다. array[position]=temp_value 테스트 코드1234array=[4, 2, 7, 1, 3]print(array)insertion_sort(array)print(array) python tutor를 이용하여 삽입정렬 이해하기 pythontutor 의 기능을 이용하여 알고리즘의 실행순서를 파악해보았다. 0번 인덱스와 1번 인덱스를 비교 후 첫번째 삽입으로 최초 정렬된 상태 temp_value &gt; array[position -1]이기 때문에 while문을 돌지 않고 바로 빠져나와서 temp_value값을 그 자리 그대로 삽입한다. 리스트에서 가장 작은 값인 1이 왼쪽의 정렬된 2, 4, 7 모두와 비교 후 0번 인덱스의 삽입 모든 비교와 삽입이 끝난 후 정렬된 상태 참고서적 누구나 자료구조와 알고리즘","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190424_TIL(quick sort)","slug":"190424-TIL-quick-sort","date":"2019-04-24T11:18:03.000Z","updated":"2019-04-25T15:50:54.869Z","comments":true,"path":"2019/04/24/190424-TIL-quick-sort/","link":"","permalink":"http://progyu.github.io/2019/04/24/190424-TIL-quick-sort/","excerpt":"","text":"quick sort(퀵 정렬)quick sort(퀵 정렬) 이란? 다른 원소와의 비교만으로 정렬을 수행하는 비교정렬에 속한다. 최악의 경우의 시간 복잡도는 선택 정렬이나 삽입 정렬처럼 O(n^2)로 좋지 않다. 하지만 퀵 정렬의 평균 수행 시간복잡도는 O(n log n)이다. 그런데 일반적인 경우 퀵 정렬은 다른 O(n log n) 정렬보다 빠른데 그 이유 중 하나는 빅오 표기법 속에 숨겨진 퀵 정렬의 상수항이 작기 때문이다. 분할 정복 기법(divide &amp; conquer) 기법을 통해 리스트를 정렬한다. 리스트에서 하나의 요소를 고른다. 고른 원소를 pivot(피벗)이라고 한다. 리스트의 안에 있는 요소들을 재배열하여 pivot 보다 작은 요소는 pivot 기준 왼쪽으로, pivot 보다 큰 요소들은 pivot기준 오른쪽으로 보낸다. 이 과정은 요소들을 오름차순으로 정렬하는 것이 목적이 아니라 pivot을 기준으로 왼쪽과 오른쪽으로 분할 하는 것이 목적이다. 분할된 두 개의 작은 리스트에 대해 재귀(Recursion)적으로 이 과정을 반복하여 정렬한다. 재귀의 base case는 리스트의 크기가 0 또는 1이 될 때이다. quick sort(퀵 정렬) 코드 with python 이해하기 위해서 많은 주석을 달면서 진행하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364def get_middle_idx(li, start, mid, end): \"\"\" 리스트 인덱스를 기준으로 처음 값과 중간 값, 마지막 값 중에서 크기가 가운데 값인 인덱스를 반환한다. \"\"\" idx_li=[start, mid, end] # to do if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1]=idx_li[1], idx_li[0] if li[idx_li[1]] &gt; li[idx_li[2]]: idx_li[1], idx_li[2]=idx_li[2], idx_li[1] if li[idx_li[0]] &gt; li[idx_li[1]]: idx_li[0], idx_li[1]=idx_li[1], idx_li[0] return idx_li[1]def quick_sort(li, start, end): # base case : 재귀 함수가 끝나는 조건을 정의 # to do if start &gt;= end: return left=start right=end # random pivot # pivot 값의 크기를 리스트의 중간 크기 값과 가깝거나 같게 만들어서 시간 복잡도가 O(n log n)인 average case로 만들기 위한 코드 # 리스트의 인덱스 기준으로 첫번째 , 중간, 마지막 값을 가져와서 그 셋 중 값의 크기가 가운데인 값을 리스트의 인덱스 기준으로 중간인 값과 교환한다. mid=(left+right)//2 mid_idx=get_middle_idx(li, start, mid, end) li[mid_idx], li[mid]=li[mid], li[mid_idx] pivot=li[(left+right)//2] # left와 right가 교차하기 \"전\"까지 while left &lt;= right: # li[left] &gt; pivot 일 때, while문을 빠져나온다. --&gt; 값을 교환해야 할 때 # li[left] &lt; pivot 이면 값을 교환하지 않고 left를 +1로 위치 이동 # left++ while li[left] &lt; pivot: left+=1 # li[right]가 pivot보다 작을 때 while문을 빠져나온다. --&gt; 값을 교환해야 할 때 # li[right]가 피벗보다 크면 값을 교환하지 않고 right를 -1로 위치 이동 # right-- while pivot &lt; li[right]: right-=1 # 교차하기 위해서 '=' 을 넣어줘야 한다. if left &lt;= right: # 값을 교환 li[left], li[right]=li[right], li[left] # left, right index 이동 left+=1 right-=1 # 재귀함수 호출 # 재귀함수를 호출하면 맨위 def로 정의한 메인함수의 매개변수 값을 변화시키고 스택을 쌓는다. # pivot 보다 작은 수 들을 정렬 # end 값이 right가 된다. quick_sort(li, start, right) # pivot 보다 큰 수 들을 정렬 # start 값이 left가 된다. quick_sort(li, left, end) test 코드12345678910import randomwhile True: num_data=int(input('데이터 개수(종료:0):')) if not num_data: break data=[random.randint(1, 100) for _ in range(num_data)] print(data) quick_sort(data, 0, len(data)-1) print(data) python tutor를 이용하여 퀵정렬 이해하기 pythontutor 의 기능을 이용하여 알고리즘의 실행순서를 파악해보았다. 위 예제 코드의 테스트 코드를 변경하여 임의의 값이 정해진 리스트를 사용하였다. 재귀함수 호출 전 분할상태 분할된 두 작은 리스트 중 pivot 보다 작은 수의 리스트를 재귀적으로 반복하여 정렬 분할된 두 작은 리스트 중 pivot 보다 큰 수의 리스트를 재귀적으로 반복하여 정렬 참고자료 wikipedia quick sort","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190423_TIL([OS] Process 와 Thread)","slug":"190423-TIL-OS-process-와thread","date":"2019-04-23T09:18:15.000Z","updated":"2019-04-23T15:45:33.619Z","comments":true,"path":"2019/04/23/190423-TIL-OS-process-와thread/","link":"","permalink":"http://progyu.github.io/2019/04/23/190423-TIL-OS-process-와thread/","excerpt":"","text":"프로세스(Process) 와 스레드(Thread) 수업 중 배운 내용과 여러 블로그를 참고하여 쓴 글 입니다. 아직 많이 부족한 실력이기 때문에 사실과 다른 점이 있을 수 있습니다. 그런 부분을 댓글로 알려주시면 정말 감사하겠습니다. 프로세스(Process)란?프로그램과 프로세스 정의 프로그램 : 어떤 작업을 하기위해 실행할 파일(하드디스크에 저장되어 있고 하나만 존재) –&gt; ex) notepad.exe 프로세스 : 메인 메모리에 올라와서 실행을 시작한 프로그램 –&gt; ex) 이미 실행되고 있는 notepad(notepad는 여러 개를 실행할 수 있다…! 하나만 존재 X) 프로세스의 특징 프로세스는 Code, Data, Stack, Heap 구조의 독립된 메모리 영역을 할당 받는다. 모든 프로세스는 기본적으로 하나 이상의 스레드(메인 스레드)를 가지고 있다. 원칙적으로 한 프로세스는 다른 프로세스의 메모리에 접근할 수 없다. 스레드(Thread)란?스레드의 정의 사전적 의미 : ‘프로세스 내에서 실행되는 여러 흐름의 단위’ 프로세스가 할당받은 자원을 이용하는 실행의 단위 스레드의 특징 Code, Data, Heap 영역을 공유하고 별도의 Stack만 가지고 있다. 각자 별도의 stack이 있기 때문에 각 스레드 마다 실행흐름을 달리 가져갈 수 있다. 멀티스레드의 장*단점 장점 프로세스와 달리 Code, Data, Heap 영역을 공유한다. 그렇기 때문에 작업량이 적고 처리비용이 감소한다. Context Switching 에 대한 오버헤드가 줄어 든다. 단점 디버깅이 어려워진다. 단일 프로세스 시스템에서는 효과를 기대하기 어렵다. 스레드 간의 통신시 데이터를 주고받는 방법은 메모리 공간을 공유하므로 그 공유자원(shared resource)을 이용하여 구현하는데, 공유자원에 각 스레드가 접근 했을 때 Round - robin Scheduling 등에 의해서 context switching이 일어나게 되는데 그 때, 일련의 과정을 보장해주지 않기 때문에 경쟁상태(race condition) 문제가 발생하게 된다. 참고 Context Switching : 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업 Round - robin Scheduling : 정해진 시간(time slice, quantum)동안 프로세스를 실행, 프로세스의 상황은 전혀 고려하지 않고 정해진 시간이 지나면 실행중인 프로세스를 바로 끌어내린다. 경쟁상태 문제해결 예시 with python 문제 해결 방법 : lock을 설정하여 thread간 공유자원 접근을 배제한다. –&gt; 상호배제(mutual exclusion) 12345678910111213141516171819202122232425262728293031323334353637383940import threading# 공유 자원# 모든 스레드에서 접근이 가능한 자원# 전역 변수g_num = 0# lock 개체lock = threading.Lock()def thread_main(): global g_num # critical section # 임계 영역 # 어떤 스레드에서 공유 자원에 접근한 후 # 수정, 변경 하려는 코드 lock.acquire() for _ in range(100000): g_num += 1 lock.release()threads = []for _ in range(50): th = threading.Thread(target=thread_main) threads.append(th)for th in threads: th.start()for th in threads: th.join()# 결과값이 계속 달라진다. --&gt; race condition 문제# 공유자원에 각각 접근 했을 때 RR 등에 의해서 context switching이 일어날 때, 일련의 과정을 보장해주지 않기 때문에 발생# 해결책 : 서로가 서로를 공유자원 접근을 배제하게 하면됨---&gt; lock. (상호배제)-- mutual exclusionprint(f'g_num : &#123;g_num&#125;') 참고자료 Context Switching process 와 thread에 대한 정리 프로세스와 스레드의 차이","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190422_TIL(first class function)","slug":"190422-TIL-first-class-function","date":"2019-04-22T09:58:11.000Z","updated":"2019-04-22T10:14:50.770Z","comments":true,"path":"2019/04/22/190422-TIL-first-class-function/","link":"","permalink":"http://progyu.github.io/2019/04/22/190422-TIL-first-class-function/","excerpt":"","text":"first class function 프로그래밍 언어 중 함수를 다른 변수와 동일하게 다루는 언어를 함수우선순위(First-class funcions)를 가졌다고 표현한다. first class function을 지원하는 언어는 다음 세 가지 조건을 충족하여야 한다. 함수를 인자(argument)로 전달할 수 있는가? 함수를 리턴(return) 값으로 전달할 수 있는가? 함수를 변수에 전달할 수 있는가? 함수를 인자로 전달12345678def f(func, a, b): return func(a, b)def g(a, b): return a+ba=10b=20f(g, a, b)# output : 30 함수를 변수에 전달1234# 위에 선언한 g() 함수를 변수에 전달t = gt(20, 30)# output : 50 함수를 리턴123456789101112def calc(kind): if kind=='add': def add(a, b): return a + b return add elif kind=='sub': def sub(a, b): return a - b return sub adder=calc('add') adder(10, 20) # output : 30 python과 JavaScript는 모두 first class function을 지원하는 언어이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"CSS-가운데 정렬(1)-margin auto","slug":"CSS-가운데-정렬-1","date":"2019-04-21T05:20:56.000Z","updated":"2019-04-21T11:21:52.903Z","comments":true,"path":"2019/04/21/CSS-가운데-정렬-1/","link":"","permalink":"http://progyu.github.io/2019/04/21/CSS-가운데-정렬-1/","excerpt":"","text":"주황색 박스를 제외한 오른쪽 공간이 auto 값으로 설정할 수 있는 margin의 최대 영역을 의미한다. 주황색 박스가 block 요소(div)이기 때문에 한 줄 전체 영역을 소유한다. 그러므로 오른쪽 공간은 쓰지 않은 것뿐 주황색 박스가 소유한 공간이다. block 요소는 한 줄에 하나씩 블럭이 쌓이듯 배치된다. text-align: center; block 요소 안에 있는 inline 요소를 가운데 정렬 시킨다.","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"http://progyu.github.io/categories/Web/CSS/"}],"tags":[]},{"title":"190420_TIL(Sass 특강)","slug":"190420-TIL-sass-특강","date":"2019-04-20T13:50:19.000Z","updated":"2019-04-20T16:13:23.043Z","comments":true,"path":"2019/04/20/190420-TIL-sass-특강/","link":"","permalink":"http://progyu.github.io/2019/04/20/190420-TIL-sass-특강/","excerpt":"","text":"4월 20일(토)Sass 특강 패스트캠퍼스에서 제공하는 주말 하루 특강을 들었다. 짧은 시간이었기 때문에 깊은 내용을 듣지는 못하고 기초적인 내용 위주로 Sass를 맛(?)봤다. 다른 프로그래밍 언어들과는 많이 다른 css를 여타 프로그래밍 언어들과 비슷하게 사용할 수 있는 점이 새로웠다. 여지껏 알던 css가 아닌 낯선 느낌이었다. css를 사용하면서 느꼈던 불편한 점들(좋지않은 재사용성, 복잡한 선택자 사용 등)을 개선할 수 있는 점이 좋았다. Sass란? Sass(Syntactically Awesome StyleSheets))는 CSS pre-processor(전처리기)로서 CSS의 한계와 단점을 보완하여 보다 가독성이 높고 코드의 재사용에 유리한 CSS를 생성하기 위한 CSS의 확장(extension) 언어이다. CSS에는 없는 문법인 선언의 중첩(Nesting), 조건문, 반복문, 변수의 사용, 다양한 연산 기능 등을 지원하여 코드의 재활용성과 가독성을 높여준다. 웹브라우저에서 스타일링에 사용되는 언어는 오직 CSS 뿐이다. Sass 스크립트 코드를 CSS 코드로 변환(compile) 시켜 줘야 한다. Mixin Sass 전체를 정리하기에는 양이 너무 많다… 수업을 들을 때 가장 흥미로웠던 부분이기도 하고 실제로도 Sass에서 가장 유용한 기능으로 손꼽히는 Mixin을 간단하게 정리하겠다. Mixin 기능은 중복을 방지하고 사용 빈도가 높은 스타일 코드를 사전에 정의하여 필요할 때 불러서 사용하는 방법이다. Mixin 기능의 특징은 프로그래밍 언어의 함수처럼 parameter(매개변수)를 사용하여 argument(전달인자)를 받을 수 있다는 것이다. MIxin의 사용법은 자주 사용할 스타일 코드 그룹을 @mixin으로 선언하고 사용할 스타일 코드 그룹 내에서 @include를 사용하여 @mixin으로 선언한 코드 그룹을 불러들이는 것이다. 예시코드12345678910111213141516@mixin boldtext($size, $color) &#123; font: &#123; family: 'Malgun Gothic' sans-serif; weight: bold; size: $size; &#125; color: $color;&#125;//순서가 바뀌어도 전달인자를 지정해주면 동작한다..boxsample &#123; @include boldtext($color:green, $size:50px);&#125;//.boxsample &#123;// @include boldtext(25px, green);//&#125; 참고자료 poiemaweb Sass-documentation heropy_blog","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190419_TIL(버블정렬(Bubble sort)정리)","slug":"190419-TIL-버블정렬(Bubble sort)정리","date":"2019-04-19T11:21:20.000Z","updated":"2019-04-19T12:48:36.298Z","comments":true,"path":"2019/04/19/190419-TIL-버블정렬(Bubble sort)정리/","link":"","permalink":"http://progyu.github.io/2019/04/19/190419-TIL-버블정렬(Bubble sort)정리/","excerpt":"","text":"4월 19일(금) 오늘은 기본정렬 알고리즘 중 버블정렬에 대하여 배웠다. 이 포스트에서는 나름대로 이해한 내용을 정리해보려 한다. 버블정렬을 이용하여 오름차순으로 정렬하기 위한 방법이다. 먼저, 버블정렬의 매커니즘을 알아보자. 다음과 같은 리스트가 있다고 가정하자 1li=[6, 2, 1, 4] 먼저, 버블정렬은 0번 인덱스의 들어있는 값과 1번 인덱스의 들어 있는 값을 비교한다. 즉, 위 리스트의 6과 2를 비교한다. 만약, 0번 인덱스의 값이 1번 인덱스의 값보다 더 크다면 두 값을 교환한다. 그렇지 않으면 교환하지 않는다. 위의 리스트의 0번 인덱스 값인 6이 1번 인덱스 값인 2보다 크기 때문에 두 값을 교환한다. 두 값을 교환한 리스트는 다음과 같다. 1li=[2, 6, 1, 4] 순차적으로 1번 인덱스와 2번 인덱스 , 2번 인덱스와 3번 인덱스를 비교한다. 위와 같은 방법으로 값을 교환한다. 위와 같은 방법으로 전체 리스트를 한번씩 비교 하고 난 후의 리스트는 다음과 같다. 1li=[2, 1, 4, 6] 큰 값을 뒤 순서로 보내는 교환을 진행하였기 때문에 전체 리스트에서 가장 큰 값이 가장 뒤에 정렬되어 있는 모습을 볼 수 있다. 따라서, 다음 비교에서는 이미 정렬된 가장 큰 값은 비교할 필요가 없다. 위 방법으로 0번과 1번 , 1번과 2번을 비교하고 교환한 리스트는 다음과 같다. 1li=[1, 2, 4, 6] 두 번째로 큰 값이 오름차순으로 정렬된 것은 물론이거니와 운이 좋게도 모든 정렬이 끝난 결과을 얻었다. 하지만, 컴퓨터는 정렬이 끝났는지 알 수 있는 방법이 없기 때문에 마지막으로 0번 인덱스와 1번 인덱스의 값을 비교한다. 비로소 컴퓨터도 정렬을 끝내었다. 다음으로, 버블정렬을 구현하기 위한 코드를 생성해보자. python 코드 123456789101112def bubble_sort(li): n=len(li) #리스트의 길이 , n=4 for i in range(n-1): # range(3): 0부터 ()안 숫자 미만의 숫자를 포함하는 객체 생성. 0, 1 ,2의 값을 가짐. for j in range(n-1-i): print(j) if li[j] &gt; li[j+1]: # 인덱스 값을 비교 li[j], li[j+1] = li[j+1], li[j] # 인덱스의 값을 교환if __name__==\"__main__\": li=[6, 2, 1, 4] bubble_sort(li) print(li) 코드 분석 바깥쪽 for문을 이용하여 전체 인덱스 비교를 n-1회 한다.(왜 n-1회 인지는 위 매커니즘 과정을 직접 따라가보면 알 수 있다.) 바깥쪽 for문을 한번 돌 때마다(i가 1씩 증가) 안쪽 for문의 최대 교환 횟수가 1씩 감소하기 때문에 -i를 해준다. i=0 일 때 j=0, j=1, j=2 i=1 일 때 j=0, j=1 i=2 일 때 j=0의 순서로 바깥쪽 for문과 안쪽 for문이 작동한다. 모든 for문이 완료되면 오름차순으로 잘 정렬된 리스트를 볼 수 있다. 관련사이트 관련사이트에서 위 코드를 복사하여 붙여넣고 Visualize Execution 버튼을 클릭하여 넘어간 페이지에서 Back 버튼과 Foward 버튼을 활용하면 버블정렬의 메커니즘을 좀 더 확실히 파악하는데 도움이 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190418_TIL(파이썬 기초정리)","slug":"190418-TIL-파이썬-기초정리","date":"2019-04-18T12:31:01.000Z","updated":"2019-04-18T12:47:48.362Z","comments":true,"path":"2019/04/18/190418-TIL-파이썬-기초정리/","link":"","permalink":"http://progyu.github.io/2019/04/18/190418-TIL-파이썬-기초정리/","excerpt":"","text":"Jump to python 내용 정리파이썬이란 무엇인가? 1990년 암스테르담의 귀도 반 로섬이 개발한 인터프리터 언어이다. 파이썬과 C는 찰떡궁합이다. 전반적인 뼈대 -&gt; 파이썬, 빠른 실행속도를 필요로 하는 부분 =&gt; C 파이썬은 줄을 맞추지 않으면(들여쓰기) 실행이 되지 않는다. “Life is too short, You need python” 파이썬은 접착(glue) 언어라고도 불리운다. why? =&gt; 다른 언어들과 잘 어울려서 파이썬은 대소문자를 구분한다. 주석은 #을 사용한다. 주석문이 여러 줄인 경우에는 &quot;&quot;&quot; 또는 &#39;&#39;&#39;을 사용한다. py는 파이썬 파일임을 알려주는 관례적인 확장자명이다. 파이썬 프로그래밍의 기초, 자료형숫자형 x의 y제곱을 나타내는 ** 연산자 나눗셈 후 몫울 반환하는 //연산자 문자열 자료형 파이썬에서 문자열을 만드는 방법 4가지 큰 따옴표로 양쪽 둘러싸기 작은따옴표로 양쪽 둘러싸기 큰따옴표 3개를 연속으로 써서 양쪽 둘러싸기 작은따옴표 3개를 연속으로 써서 양쪽 둘러싸기 \\ (백슬래시)를 작은 따옴표(&#39;)나 큰따옴표(&quot;) 앞에 삽입하면 문자 자체로 인식한다. 여러 줄인 문자열을 변수에 대입하고 싶을 때는 연속된 작은 따옴표 3개(&#39;&#39;&#39;)나 큰따옴표 3개(&quot;&quot;&quot;)를 이용한다. 문자열 곱하기는 문자열을 반복하는 용도로 사용된다. 사용예시 12345678print(\"=\" * 50)print(\"My Program\")print(\"=\" * 50)# 결과값==================================================My Program================================================== 문자열 길이 구하기 =&gt; len() 문자열 인덱싱 =&gt; a[번호] 파이썬은 0부터 숫자를 센다 마이너스(-) 기호를 사용하여 문자열을 뒤에서 부터 인덱싱 할 수도 있다. 문자열 슬라이싱 =&gt; a[시작번호:끝번호] 끝번호에 해당하는 것은 포함되지 않는다. 공백 문자 역시 문자와 동일하게 취급한다. 자주 사용하는 문자열 슬라이싱 기법 1234567&gt;&gt;&gt; a = \"20010331Rainy\"&gt;&gt;&gt; date = a[:8]&gt;&gt;&gt; weather = a[8:]&gt;&gt;&gt; date'20010331'&gt;&gt;&gt; weather'Rainy' 숫자 8을 기준으로 a[:8]은 시작번호가 없기 때문에 처음부터 a[8] 전까지 a[8:]은 a[8]을 포함하여 문자열 끝까지 이다. 문자열 요소값 바꾸기 문자열 요소값은 바꿀 수 있는 값이 아니다. =&gt; 문자열 자료형은 immutable한 자료형이다. 문자열 요소를 바꾸는 방법 중 하나는 바꿀 문자열 요소를 제외한 부분을 슬라이싱하고 따로 바꿀 요소 값을 더해서 연결해주면 된다. 문자열 포매팅 문자열 내에 어떤 값을 삽입하는 방법 %d (정수 포매팅), %s(문자열 포매팅) 2개 이상의 값을 넣고 싶을 땐 콤마(,)로 구분한다. 포매팅 연산자 %d와 %를 같이 쓸 때는 %%를 쓴다. 문자열 관련 함수들 문자 개수 세기 (count) 위치 알려주기1 (find) 위치 알려주기2 (index) =&gt; find 함수와 다른 점은 존재하지 않는 문자를 찾으면 오류 발생 문자열 삽입(join) 양쪽 공백 지우기(strip) 문자열 나누기(split) 참고자료","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"python","slug":"python","permalink":"http://progyu.github.io/tags/python/"}]},{"title":"190417_TIL(컴퓨터공학기초,32bit 와 64bit, 기수법, 정수(Integer)의 표현, 보수, 산술연산)","slug":"190417-TIL-컴퓨터공학기초-32bit-와-64bit-기수법-정수-Integer-의-표현-보수-산술연산","date":"2019-04-17T11:48:12.000Z","updated":"2019-04-17T15:00:43.595Z","comments":true,"path":"2019/04/17/190417-TIL-컴퓨터공학기초-32bit-와-64bit-기수법-정수-Integer-의-표현-보수-산술연산/","link":"","permalink":"http://progyu.github.io/2019/04/17/190417-TIL-컴퓨터공학기초-32bit-와-64bit-기수법-정수-Integer-의-표현-보수-산술연산/","excerpt":"","text":"4월 17일(수)32bit 컴퓨터와 64bit 컴퓨터를 나누는 기준 첫번째 기준 : cpu와 RAM(main memory) 사이를 연결하는 와이어의 갯수 —&gt; bit 갯수 즉, 와이어가 8개이면 8비트 두 번째 기준 : 메모리 주소값 - &gt; digit(자릿수)이 32개, 베이스는 2진수 –&gt; 32비트 컴퓨터 컴퓨터 메모리 기초 메모리 주소는 우편주소와 유사하다. 메모리에서는 1byte 하나당 메모리 주소를 하나 할당한다. 1byte == 8bit 32비트 컴퓨터는 0 ~ 2^32 -1 메모리 주소를 할당할 수 있다. –&gt; 계산하면 4g 정도 나옴. RAM이 4g면 충분 —&gt; 이미 메모리 주소를 다 할당했기 때문에 더이상 할당할 주소가 없다. 기수법 2진수(Binary), 10진수(Decimal), 16진수(Hexadecimal)를 알아둘 필요가 있다. 2, 10 ,16 진수를 나누는 기준 : 한 자릿수에 표현할 수 있는 수의 개수 16진수는 0~9 , 10 이후는 a ~ f 까지 16진수 1개가 2진수 4개로 변환된다. ex) 16진수 8자리면 32bit 메모리 주소를 표현할 수 있다. 정수(Integer)의 표현 int는 system을 따라간다. 32bit컴퓨터에서 32bit즉 4byte를 차지한다. 자바스크립트는 모든 숫자가 실수형인 double(8byte)로 들어간다. –&gt; cpu를 많이 잡아먹는다. 1byte로 표현할 수 있는 정수의 범위 -2^7 ~ 2^7 - 1 양의 정수의 표현 : 부호비트가 0이다. 음의 정수의 표현 : 부호비트가 1 이다. , 2의 보수로 저장한다. 음의 정수를 2의 보수로 표현하는 이유 2의 보수를 사용하지 않는다면 0000 0000과 1000 0000이 모두 0을 표현한다. 1비트가 낭비된다. if문으로 비교 시 엉뚱한 결과가 나온다. 컴퓨터는 가산기(adder) 즉, 덧셈만으로 뺄셈을 하는데 이 때 2의 보수의 역할이 중요하다. 보수 보수란 쉽게 말해서 보충해 주는 수이다. 10진수의 9의 보수는 9에서 어떤 수의 각 자릿수 수를 뺀 값 —&gt; ex)26의 9의 보수는 73 10의 보수는 9의 보수에 1을 더한 값 —&gt; ex)26의 9의 보수는 74 2진수의 1의 보수는 10진수의 9의 보수와 같은 원리로 1에서 각 자릿수를 뺀 값이다. —&gt; ex)1010의 1의 보수는 0101, 그런데 결과를 유심히 살펴보면 각 자릿수 수의 1과 0을 반전하면 1의 보수가 된다는 것을 알 수 있다. 2진수의 2의 보수는 1의 보수에 1을 더한 값이다. ex) 1010—&gt; 0110 2의 보수가 중요한 이유는 컴퓨터가 음수를 표현할 때 2의 보수를 사용하기 때문이다. Number 산술연산 가산기(adder)만으로 덧셈, 나눗셈, 곱셈을 어떻게 할까?? —&gt; 2의 보수와 shift register를 활용한다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"컴퓨터공학기초","slug":"컴퓨터공학기초","permalink":"http://progyu.github.io/tags/컴퓨터공학기초/"}]},{"title":"190416_TIL(반응형 이미지, 그리드 레이아웃)","slug":"190416-TIL-반응형-이미지-그리드-레이아웃","date":"2019-04-16T12:02:36.000Z","updated":"2019-04-16T16:09:42.230Z","comments":true,"path":"2019/04/16/190416-TIL-반응형-이미지-그리드-레이아웃/","link":"","permalink":"http://progyu.github.io/2019/04/16/190416-TIL-반응형-이미지-그리드-레이아웃/","excerpt":"","text":"4월 16일(화)반응형 배경이미지 전체 페이지를 배경이미지로 덮는 웹 페이지 또는 마크업에 들어가지 않아도 될 이미지 요소를 반응형으로 만들고 싶을 때 사용하는 방법. padding trick을 사용한다. iframe 태그를 반응형으로 만드는 원리와 유사하다. 반응형 배경이미지 예제 우측 상단 Edit in JSFiddle 링크를 클릭하여 뷰포트 넓이를 조절하면 된다. 핵심은 padding trick이다. padding-top 값을 사실상 height값으로 사용할 수 있도록 calc() 를 이용하여 이미지의 height / width * 100% 즉, 백분율값을 주어서 원본 이미지의 비율을 유지할 수 있게하였다. 그리드 레이아웃 column(행) 과 row(열)을 이용하여 구역을 나누고 요소들을 배치하는 레이아웃 속성 비교적 쉽고 간편하게 전체적인 레이아웃을 만들 수 있으나 IE 호환 이슈가 있기 때문에 현업에서는 많이 사용하지 않는다. caniuse grid 는 현재 파이어폭스 개발자 모드가 크롬 개발자보다 더 잘 지원해준다. 간단한 게임을 통해 grid를 이해하는데 도움을 주는 사이트 grid-garden grid column 계산에 도움을 주는 사이트 grid-calculator","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190415_TIL(반응형 웹,미디어 쿼리,반응형 이미지)","slug":"190415-TIL-반응형-웹-미디어-쿼리-반응형-이미지","date":"2019-04-15T11:45:48.000Z","updated":"2019-04-15T14:54:48.105Z","comments":true,"path":"2019/04/15/190415-TIL-반응형-웹-미디어-쿼리-반응형-이미지/","link":"","permalink":"http://progyu.github.io/2019/04/15/190415-TIL-반응형-웹-미디어-쿼리-반응형-이미지/","excerpt":"","text":"4월 15일(월)반응형 웹 마크업 구조가 심플 할 때 유용하다. 반응형 디자인이 되기 위해서는 콘텐츠가 물과 같아야 한다. 모바일 버전을 먼저 만드는 것을 권장한다. px(픽셀) 단위의 사용은 지양해야 한다. 모바일 환경과 같은 환경에서 이미지를 줄이는 것만이 능사가 아니다 사용자에게 보여주어야할 부분을 잘라내어서 확대해야 할 때도 있다. 반응형 웹 만들 시 유용한 사이트 미디어 쿼리 미디어 쿼리는 반응형 디자인을 만들기 위한 가장 강력한 도구. 다양한 방법들이 존재하지만 뷰포트 넓이에 대응하여 min-width, max-width 속성을 사용하는 것이 가장 일반적이다. 뷰포트 넓이를 조건으로 하여서 각기 다른 디자인을 적용한다. 미디어쿼리 예제 우측 상단 Edit in JSFiddle 링크를 클릭하여 뷰포트 넓이를 조절하면 된다. 반응형 이미지 반응형 이미지는 원본 이미지 크기 이상은 늘어나지 않도록 하기위해 div 같은 의미 없는 요소로 감싼 후 div 즉, 부모요소를 이용하여 사이즈를 조절하고 이미지 자체에는 max-width 속성을 부여한다. 반응형 이미지 예제 우측 상단 Edit in JSFiddle 링크를 클릭하여 뷰포트 넓이를 조절하면 된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"transition and transform","slug":"transition-and-transform","date":"2019-04-13T15:22:50.000Z","updated":"2019-04-14T14:47:48.680Z","comments":true,"path":"2019/04/14/transition-and-transform/","link":"","permalink":"http://progyu.github.io/2019/04/14/transition-and-transform/","excerpt":"","text":"Transition(이전)과 Transform(변형) 이해하기 Trasition(전이) 요소 박스에 지정된 속성이 점진적으로 변환하는 기능을 의미한다. 이 기능을 이용하면 속성이 변화하는 과정을 통해 애니메이션 효과가 적용되어 동적인 느낌을 줄 수 있다. transition property 속성 요소에 지정된 속성을 변환하고자 할 때 사용하는 속성. 속성 값으로 특정 CSS 속성을 지정하면 해당 속성만 변환되고, all을 지정할 경우 요소에 지정된 모든 속성이 변환된다. 위 코드에서는 all을 지정하였다. 위 코드의 주석처리 된 부분이 all을 지정하였을 떄와 같은 결과 값을 가진다. transition–duration 속성 변환이 진행되는 시간을 지정하는 속성. 시간은 초 단위(s)로 지정 위 코드에서는 2s로 지정하였다. 2초 동안 지정한 변환을 수행한다. transition–delay 속성 transition-delay는 변환이 진행되기 전 지연되는 시간을 지정하는 속성. transition-duration 속성과 마찬가지로 지연 시간은 초 단위(s)로 지정. 이때 지연되는 시간은 진행 시간(transition-duration)에 포함되지 않는다. 위 코드에서는 따로 지정을 하지 않았으나 ease-in 뒤에 2s 같은 초단위 값을 입력하면 된다. transition–timing–function 속성 transition-timing-function은 속성이 변환될 때 진행 속도의 형태를 지정하는 속성. 위 코드에서는 ease-in을 사용하였다. ease-in은 후반부로 갈수록 변환 시 진행 속도가 증가되는 형태이다. transition 속성 transition은 transition 관련 속성 값들을 일괄 적용하는 대표 속성으로, transition 속성 값은 공백으로 구분하여 선언한다. 위 코드에서는 대표속성인 transition 속성을 사용하여 일괄 적용하였다. Transform(변형) transform 관련 속성을 사용하면 요소 박스의 크기 변형 및 회전, 기울임 등을 지정할 수 있다. 또한 평면상의 2차원 변형뿐만 아니라 3차원 변형도 가능. 이번 포스트에서는 2차원 변형에 대해서만 다룰 예정이다. transform 속성 transform은 요소 박스를 변형하는 속성으로, 변형 형태별로 함수 타입의 속성 값을 지정한다. 이때 속성 값을 공란으로 구분하여 복수의 속성 값을 지정할 수 있다. translate() translate( ) 함수는 HTML 요소 박스를 평면상에서 수평 이동하는 기능이다. . translate( )로 이동된 요소는 다른 요소의 배치에 영향을 끼치지 않는다. 위 코드에서는 x축 좌표로 150px 이동하는 translateX(150px) 함수가 사용되었다. 1div &#123; transform : scale(0.5, 0.5) ; &#125; 위와 같이 사용할 수도 있다. scale() scale( ) 함수는 HTML 요소 박스의 크기를 변형하는 기능이다. scale( ) 함수 역시 변경된 요소의 크기가 다른 요소 배치에 영향을 끼치지 않는다. 위 코드에서는 본래 요소 박스 크기의 반만큼 작아지는 함수가 사용되었다. rotate(angle) rotate( ) 함수는 HTML 요소 박스를 평면상에서 회전하는 기능으로, 함수의 값으로 회전 각도(deg)를 지정할 수 있다.이 때 회전 각도가 양수 값일 경우에는 시계 방향으로 회전하고, 음수 값일 경우에는 반 시계 방향으로 회전한다. rotate( ) 함수 역시 박스가 회전되어 요소의 표시 영역이 변경되더라도 다른 요소의 배치에는 영향을 끼치지 않는다. 위 코드의 rotate(1turn) 과 같이 사용 가능하다. skew skew( ) HTML 요소 박스의 기울임을 지정하는 기능이다. rotate( ) 함수와 마찬가지로 함수 값에 기울기의 각도(deg)를 지정할 수 있다. 박스가 회전되어 요소의 표시 영역이 변경되더라도 다른 요소의 배치에는 영향을 끼치지 않습니다. 위 코드에서는 사용되지 않았다.","categories":[{"name":"Web","slug":"Web","permalink":"http://progyu.github.io/categories/Web/"},{"name":"CSS","slug":"Web/CSS","permalink":"http://progyu.github.io/categories/Web/CSS/"}],"tags":[]},{"title":"190412_TIL(transition, transform, IR, hexo menu, jsfiddle)","slug":"190412_TIL(transition, transform, IR, hexo menu, jsfiddle)","date":"2019-04-12T17:33:34.000Z","updated":"2019-04-13T15:09:01.317Z","comments":true,"path":"2019/04/13/190412_TIL(transition, transform, IR, hexo menu, jsfiddle)/","link":"","permalink":"http://progyu.github.io/2019/04/13/190412_TIL(transition, transform, IR, hexo menu, jsfiddle)/","excerpt":"","text":"4월 12일 (금) transition(전이) 속성과 transform(변형) 속성에 대하여 배웠다. Transition(전이)요소 박스에 지정된 속성이 점진적으로 변환하는 기능을 의미. 애니메이션 효과를 적용할 수 있다. Transform(변형)요소 박스의 크기 변형 및 회전, 기울임 등을 지정할 수 있다. 2차원 변형 뿐만 아니라 3차원 변형도 가능하다. IR(Image Replacement) 기법 중 Glider/Levin Method에 대하여 배웠다. IR(Image Replacement)안내문을 디자인상의 이유로 일반 텍스트가 아닌 이미지로 게시해야 하는 등의 상황. 또는 웹 페이지를 개발할 때 스크린리더 사용자에게 특정 이미지에 대한 추가 설명을 제공해야 할 때도 있다. 이렇게 이미지를 볼 수 없는 사용자에게 대체된 텍스트를 제공하는 것을IR(Image Replacement) 기법이라고 한다. Glider/Levin Method이미지로 대체할 엘리먼트 내에 빈 span 태그를 추가하여 배경이미지를 설정하고 position: absolute 스타일을 이용하여 글자를 덮는 방법. 출처 및 참고 hexo 블로그의 메뉴와 카테고리를 만들었다. hexo 블로그 메뉴와 카테고리 만들기메뉴와 카테고리를 만드는 방법은 생각보다 훨씬 간단했다. 방법을 찾느라 많은 시간을 보낸게 허무할 정도. hexo에 포스트 할 .md 파일 최상단에 있는 Front-matter 영역의 다음과 같이 categories를 추가한다. 블로그의 WEB이라는 새로운 메뉴와 카테고리가 생성된다. 이미 생성된 categories를 입력하면 관련 메뉴 및 카테고리 내로 글이 분류된다. 1234title: test date: 2019-04-13 02:33:34categories: WEB-------------------------------------------- 하위 메뉴를 생성하기 위해서는 다음과 같이 입력한다. 블로그의 WEB이라는 메뉴의 하위 메뉴로 HTML이 생성된다. 123456title: test date: 2019-04-13 02:33:34categories:- WEB- HTML -------------------------------------------- 출처 및 참고 jsfiddle이라는 웹사이트를 이용하여 블로그 내에 html, css , javascript 등의 코드와 그 실행결과를 바로 보여줄 수 있는 방법을 찾았다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190411_TIL(web cafe event section markup,figure tag, hexo theme, IR기법,IS기법)","slug":"190411-TIL-web-cafe-event-section-markup-hexo-theme-ir기법-is기법","date":"2019-04-11T16:02:15.000Z","updated":"2019-04-13T15:26:05.044Z","comments":true,"path":"2019/04/12/190411-TIL-web-cafe-event-section-markup-hexo-theme-ir기법-is기법/","link":"","permalink":"http://progyu.github.io/2019/04/12/190411-TIL-web-cafe-event-section-markup-hexo-theme-ir기법-is기법/","excerpt":"","text":"4월 11일 (목) 어제 사용해 보기로 한 카카오 오븐을 오늘 html markup 설계에 사용해 보았다. 사용 방법이 직관적이어서 적응하는데 오래 걸리지 않았고 손으로 수작업 하는 것보다 짧은 시간 안에 더욱 그럴듯한 모양새를 갖출 수 있었다. html markup 설계 뿐만이 아니라 css 설계에도 활용할 수 있을 것 같다. 수업 중에 figure 태그를 새롭게 배웠다. figure 태그는 이미지, 도표 등을 직접적으로 설명하는 문구가 필요할 때 사용하는 태그이다. 사용방법은 이미지나 도표 등을 나타내는 태그와 이를 직접적으로 설명하는 문구인 figcaption 태그를 형제 레벨로 배치하고 figure 태그로 그 둘을 감싸는 것이다. 1234&lt;figure&gt; &lt;img src=\"blackhole.png\"&gt; &lt;figcaption&gt;최초 촬영된 블랙홀&lt;/figcaption&gt;&lt;/figure&gt; 관련 참고자료 IR 기법과 IS을 수업 마지막 쯔음에 잠깐 배웠다. 용어의 정의나 두 기법을 사용하는 이유는 알았지만, 다양한() 사용방법에 대한 이해는 아직 부족한듯 하여서 관련 article들을 찾아봤지만 아직 마땅한 article을 찾지 못하였다. 대신 위에서 언급한 용어의 간단한 ()정의와 두 기법을 사용하는 이유에 대해 아주 간략하게 정리한 블로그를 발견하였다. 수업이 끝나고 hexo blog에 테마를 적용해 보았다. 테마는 다양한 기능들을 간단하게 적용할 수 있는 장점이 있는 Hueman 테마를 적용하였다. 블로그를 참고하여 설치를 진행하였다. 생각보다 많이 어렵지는 않았다. 테마를 적용한 후 _config.yml 파일에서 필요한 커스터마이징을 진행하였다. 먼저 sidebar에 위치를 왼쪽에서 오른쪽으로 바꾸었다. 다음으로 이미지가 많이 적용되어 있지 않은 나의 글 들을 감안하여 Thumnail 이미지를 보여주지 않게 설정하였다. facebook, github 아이콘의 실제 내 페이지 링크 걸기, favicion 설정하기 등 여러가지 커스터마이징을 진행하였다. 이번주 안으로 블로그명을 짓고 home header 사진을 변경하고 , 메뉴 및 카테고리를 만들 생각이다. -커스터마이징 관련 참고1-커스터마이징 관련 참고2-커스터마이징 관련 참고3","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[{"name":"hexo theme","slug":"hexo-theme","permalink":"http://progyu.github.io/tags/hexo-theme/"}]},{"title":"190410_TIL(LINE 웹페이지 header html,css, fontello)","slug":"190410-TIL-line-웹페이지-header-css-fontello","date":"2019-04-10T15:57:57.000Z","updated":"2019-04-12T12:22:03.735Z","comments":true,"path":"2019/04/11/190410-TIL-line-웹페이지-header-css-fontello/","link":"","permalink":"http://progyu.github.io/2019/04/11/190410-TIL-line-웹페이지-header-css-fontello/","excerpt":"","text":"4월 10일 (수) 오늘은 과제로 LINE Plus Coporation 의 header 부분의 HTML markup 과 CSS 작업을 하였다. 코딩에 들어가기에 앞서 아래 사진과 같이 수작업으로 설계를 해보았다. 수작업으로 설계를 해보니 꼼꼼한 작업을 할 수 있다는 장점이 있지만 시간이 많이 소요되어서 지루하게 느껴지는 단점이 있다. 다음 설계는 카카오 오븐과 같은 툴을 사용해 볼 생각이다. LINE css 작업을 진행하면서 fontello로 아이콘을 넣어봤다.기존의 아이콘을 사용할 때는 i태그를 사용하거나 image 파일을 사용하는 방식이었는데 fontello는 class를 html 요소의 추가하는 방식으로 아이콘을 사용할 수 있어 간편했다. 사용방법은 비교적 어렵지 않고 아래와 같이 사용하면 된다. fontello사이트의 접속 후 원하는 아이콘을 클릭하고 우측 상단에 있는 Download webfont 버튼을 클릭한다. 압축을 풀고 font 폴더와 fontello.css 파일을 현재 작업중인 폴더로 복사한다. fontello.css에서 설정을 변경한다. 먼저 font 폴더의 경로가 잘 설정되어 있는지 확인한다. 1$ src: url('../font/fontello.eot?63304039'); fontello는 가상요소를 이용하여 html요소의 앞 뒤에 배치한다. before를 after로 변경할 수 있다. 1$ [class^=\"icon-\"]:before, [class*=\" icon-\"]:before fontello.css의 가장 하단에 아이콘 클래스와 가상요소가 정의되어 있다. 새로운 아이콘을 사용하고 싶을 때는 이 부분만 넣어주면 된다. 1$ .icon-cog-alt:before &#123; content: '\\e800'; &#125; /* '' */ :before 가상요소 앞에 있는 class를 html 요소의 class의 넣어주기만 하면 아이콘을 사용할 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190409_TIL(탭메뉴,white-space:nowrap, .on() method, 유사배열,async and defer)","slug":"190409-TIL-탭메뉴-white-space-nowrap-on-method-유사배열-async-and-defer","date":"2019-04-09T12:24:27.000Z","updated":"2019-04-12T15:23:37.821Z","comments":true,"path":"2019/04/09/190409-TIL-탭메뉴-white-space-nowrap-on-method-유사배열-async-and-defer/","link":"","permalink":"http://progyu.github.io/2019/04/09/190409-TIL-탭메뉴-white-space-nowrap-on-method-유사배열-async-and-defer/","excerpt":"","text":"4월 9일 (화) 오늘은 탭메뉴를 float , position 속성 등을 사용하여 다양하게 구현해보았다. html 이나 css 보다는 탭메뉴를 동적으로 만들기 위한 방법을 정리해보고자 한다. 동적인 탭메뉴를 만들기 위한 class를 처음에 보여질 탭메뉴 태그의 작성한다. 위에서 만든 class에 display:block; 스타일을 입힌다. 나머지 첫화면에 표시하지 않을 탭메뉴 내용들은 display:none;으로 숨김 처리한다. 자바스크립트를 이용하여 class를 동적으로 생성하고 삭제한다. 기타 배운 내용들 정리 Whiite-space: nowrap;부모 영역을 벗어나더라도 한줄로 나오게 한다. 즉, wrap 하지 않게 한다. .on() method를 사용하면 하나의 이벤트 핸들러에 여러 개의 이벤트를 동시에 연결할 수 있다. 참고자료 한 선택자에 여러 요소가 있으면 유사배열 형식으로 값을 반환한다.예를들면 아래와 같이 여러 li 태그들의 class로 적용되어 있는(가정) .menu-item은 li태그를 유사배열 형식으로 반환한다. 12$ var item = $(&apos;.menu-item&apos;);$ console.log(item); // 유사배열 값 반환. 유사배열은 아직 많은 부분이 이해가 가지 않는다. 앞으로 더욱 많은 배움을 통해 알아가자! 유사배열 참고자료 일반적인 &lt;script&gt; 실행은 인라인 코드의 경우 즉시 해석되고 실행되지만 그렇지 않은 경우는 해당 js 파일을 가져올 때까지 HTML 문서의 구문 분석을 중단한다. async속성이 추가된 경우의 실행은 HTML 구문 분석과 병행하여 스크립트를 가져온 후 스크립트가 준비 될 때마다 즉시 실행이 가능하다. 실행 순서가 다운로드 완료 시점의 결정되므로 사용에 주의해야 한다. defer 속성이 추가된 경우의 실행은 HTML 구문분석이 실행되는 동안 스크립트 파일을 다운로드 할 수 있다. 그러나 HTML 구문 분석이 완료 되어야 스크립트가 실행된다. 호출된 순서대로 실행된다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190408_TIL(Float, Clearfix)","slug":"190408-TIL-float-clearfix","date":"2019-04-08T15:14:52.000Z","updated":"2019-04-15T11:45:56.827Z","comments":true,"path":"2019/04/09/190408-TIL-float-clearfix/","link":"","permalink":"http://progyu.github.io/2019/04/09/190408-TIL-float-clearfix/","excerpt":"","text":"4월 8일 (월)수업시간에 float 만을 활용하여 layout을 잡는 연습을 하였다. float 란 일반적인 흐름(normal flow)를 벗어나 부모 요소의 왼쪽이나 오른쪽에 배치하는 것이다. float로 요소를 배치하는 것은 상당히 까다로운 일인데 그 이유는 다른 요소의 배치에 영향을 미치기 때문이다. float가 배치에 영향을 미치는 것을 해제하기 위한 속성이 clear이다. clear 속성 같이 반복적으로 사용되는 속성을 css에서 임의의 클래스로 만들어 html 태그 class 값으로 주어 사용하는데 이를 css 모듈화 라고 한다. clear 속성을 모듈화 하는 것은 이미 보편적으로 사용하고 있고 clearfix라는 명칭도 있다. clearfix는 임의의 클래스에 ::after와 같은 가상요소를 넣고 빈 블럭을display:block으로 만들고 clear: both를 사용하여 float 속성 값을 초기화하는 것이다. 다만, clearfix는 float 했을 시 부모가 자식 요소의 높이를 잃어버리는 것을 방지하기 위해 부모요소에 적용하는 것이다. 형제 레벨에서는 clear: both; 속성을 이용하여 float된 객체 만큼의 margin을 추가하여 겹치지 않게 해야한다. float 속성에 대하여 여러모로 공부를 좀 했지만 아직도 많은 부분 부족한거 같다. 생활코딩 강의 등을 통하여 좀 더 확실히 배워야겠다. clearfix참고 CSS모듈참고","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190331-0401_TIL(프로젝트 보완, box-sizing 속성, box model, flex box)","slug":"190331-0401-TIL-프로젝트보완-box-sizing 속성-box-model-flex-box","date":"2019-04-01T10:50:22.000Z","updated":"2019-04-12T15:23:22.732Z","comments":true,"path":"2019/04/01/190331-0401-TIL-프로젝트보완-box-sizing 속성-box-model-flex-box/","link":"","permalink":"http://progyu.github.io/2019/04/01/190331-0401-TIL-프로젝트보완-box-sizing 속성-box-model-flex-box/","excerpt":"","text":"3월 31일 (일) 오늘은 프로젝트에서 아직 부족한 점을 보완하기 위해서 오후 시간을 비워뒀다. 총 세 가지의 보완사항이 있었는데 첫번째는 to-do 입력 시 input 창 안이 공백이어도 입력이 되는 문제를 보완해야 하는 사항이었다. 이 문제는 간단하기 때문에 가장 먼저 처리하기로 했다. 조건문에 input 창 안이 공백이면 alert 창을 띄움으로써 해결하였다. 두번째 보완사항은 배경 이미지를 선택하여 변경 이후 다시 로드할 때 변경된 이미지 값이 저장되지 않는 사항이었다. 로컬스토리지에 저장하면 해결될 사항이었다. 우선 배경이미지를 저장할 함수를 하나 생성하여 .css() 메서드로 &#39;background&#39; 값을 가져오고 배경이미지를 클릭하여 선택할 시 함수를 호출하여 저장하게 하였다. 그리고 로드할 함수를 하나 더 생성하여 .css()매서드로 &#39;background&#39; 값을 가져오고 함수를 호출하여 로드하였다. 마지막은 클래스가 겹치는 현상으로 인하여 같은 위치에 포스트잇이 겹치는 현상을 해결하여야 했다. 클래스의 중복문제를 해결해보고자 했지만 잘 해결이 되지 않아서 아예 다른 방법을 고안하였다. 그것은 포스트잇이 하나 생성될 때마다 위치 값을 랜덤으로 주는 방식이다. 먼저 랜덤한 수를 생성하기 위하여 Math.random()매서드를 사용하였다. 그 다음 .find() 매서드와 .css() 매서드를 이용하여 포스트잇에 위치 값을 주었다. 그리고 나서 이 랜덤 한 위치 값을 로컬스토리지에 저장하여 랜덤한 위치를 가지는 포스트잇으로 문제를 보완하였다.주말에 골치 아픈 문제를 가지고 씨름하고 머리 아프고 힘들었지만 문제를 보완한 이후에 오는 뿌듯함이 그 모든 것을 상쇄시켰다. 보람찬 하루로 기억될 것 같다. 4월 1일 (월) 오늘은 김데레사 강사님의 첫 강의 시간이었다. 설렘 반 걱정 반으로 수업에 참여하였는데 정말 기초부터 탄탄하게 잘 가르쳐주셔서 많은 배움이 있었던 하루였다. 오늘 배운 정말 많은 내용 중에서도 가장 중요하다고 생각되는 box-sizing 속성, box model 그리고 flex model을 정리하도록 하겠다. box-sizing 속성 content-box는` 요소 박스에 지정된 모든 값을 더해 박스의 크기를 결정하는 방식. 예를들어, 콘텐츠 너비가 200px이고 안쪽 여백(padding) 크기가 40px, 그리고 테두리 굵기(border)가 10px인 실제 박스의 크기는 앞에 값을모두 더한 값인 250px이 된다. border-box는 콘텐츠에 지정된 너비인 200px에 안쪽 여백(padding)인 40px과 테두리 굵기(border)인 10px이 포함된다. 그렇게 되면 실제 박스의 크기는 250px이 아니라 200px이 된다. box model margin 속성은 padding 속성과 달리 속성 값에 음수 값을 사용할 수 있다. 그리고 margin-[방향]의 상세 속성을 이용하여 방향별로 지정할 수도 있으며, 이때는 하나의 속성 값만 사용할 수 있다.margin의 특성 중에 상하로 인접한 박스의 display 속성 값이 &quot;block&quot;인 경우, 마진 겹침(Margin Collapsing) 현상이 발생한다.margin-bottom 속성 값이 “10px”이고, B 요소의 margin-top 속성 값이 20px”일 때 두 요소 사이의 margin은 20px로 적용된다. flex model flexboxs는 주축과 교차축이라는 두 개의 축이 존재한다. 주축은 flex-direction 속성을 사용하여 지정하며 교차축은 이에 수직인 축으로 결정된다. flex-direction의 속성은 row , row-reverse, column, column-reverse로 나뉜다.row , row-reverse는 인라인 방향을 따르고 column, column-reverse은 블록 방향을 따른다. flexbox는 주축, 교차축을 따라 항목을 정렬하고 끝을 맞추는 각종 속성들을 적용하는 방식으로 동작한다. flex 컨테이너를 생성하려면 영역 내의 컨테이너 요소의 display 값을 flex 혹은 inline-flex로 지정한다. flex 항목들은 각 항목 별 내부 요소의 크기로 주축을 따라 정렬된다. flex 요소의 정렬 방향은 “왼쪽, 오른쪽, 위, 아래”를 사용하지 않고 시작선 , 끝선을 사용한다. flex-direction: row-reverse 라고 지정하면 행으로 나열되는 것은 그대로지만 시작 선과 끝 선이 서로 바뀌게 된다. flexbox는 1차원 모델이지만 flex 항목이 여러 행에 나열되도록 할 수 있다. 그 경우 각 행이 새로운 flex 컨테이너라고 생각해야 한다. 공간 배분은 해당 행에서만 이루어지며 다른 행은 영향을 받지 않는다. 항목이 여러 행에 나열되도록 하려면 flex-wrap 속성의 값을 wrap으로 지정해야한다. 그림으로 배우는 flex model, 게임으로 배우는 flex model, 이론 참고 사이트","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190327-0330_TIL(프로젝트, 개발 프로젝트 단계 특강)","slug":"190327-0330-TIL-프로젝트-개발-프로젝트-단계-특강","date":"2019-03-31T08:46:08.000Z","updated":"2019-04-12T15:23:17.613Z","comments":true,"path":"2019/03/31/190327-0330-TIL-프로젝트-개발-프로젝트-단계-특강/","link":"","permalink":"http://progyu.github.io/2019/03/31/190327-0330-TIL-프로젝트-개발-프로젝트-단계-특강/","excerpt":"","text":"3월 30일 (토) 오늘은 패스트캠퍼스에서 주최하는 기초개발특강(UX, UI, 개발 프로젝트 단계)를 듣고 왔다. 자리가 제한되어 있었기 때문에 신청한 사람들 중에 선착순으로 들을 수 있었는데 다행히 제한인원 안에 들었다. 이 특강을 신청한 이유는 평소에도 실제 개발 업무에서 프로젝트가 어떻게 진행되는지 궁금했기 때문이다. 오늘 강의로 그 궁금증을 풀 수 있을지 걱정 반 기대 반이 었는데 아주 만족스러운 내용의 강의였다. 오늘 배운 내용을 모두 정리하기에는 그 양이 너무 방대할 것으로 예상되기 때문에 강사님이 강조한 부분과 내 기억에 많이 남는 부분 위주로 정리하겠다. 웹 서비스 개발 프로젝트의 단계는 기획 - 디자인 - 개발 - 테스트 - 배포 나뉜다. 그중에서도 디자인 - 개발 - 테스트 가 개발단계로 분류된다. 프론트엔드 개발자는 당연히 개발 업무가 주업무이다. 동료 기획자, 디자이너, 개발자와의 원활한 의사소통이 중요하다. 그러기 위해서 기획자나 디자이너가 자주 쓰는 용어들을 알아두면 좋다. 각 요소 하나 하나에만 신경쓰지 말고 전체적인 flow도 생각하기, ux를 고려할 때 웹이나 앱 안에서만 갇혀서 생각하지 말고 실제 사용자가 되어 생각해보기. 예) 쏘카 이용자들은 차를 처음 탔을 때는 쏘카 앱을 잘 보지 않고 목적지만을 향해 간다. 따라서, 전 사용자에 대한 평가를 차를 타고난 직후가 아닌 차를 탄 이후에 하게 하는 것이 좋다. github issue page, 코드리뷰, Scrum Board, Kanban Board 등을 통해 협업하고 의사소통하기 프로젝트 매니징 : IA 설계, WBS, Gantt-Chart, Agile 처음에 이런 저런 기능을 붙이기 보다는 핵심 기능 한가지를 찾아내고 그 기능이 정말 잘 돌아가게 만든 후 확장하기 예) toss 3월 29일 (금) 오늘은 프로젝트의 마지막 날이다. 기능적인 부분들은 어제 완료를 했기 때문에 오늘은 세부적으로 디자인 요소를 변경하고 팀원들과 코드를 합치는 일을 하였다. 먼저 화면 전체를 채우고 있는 이미지 요소의 크기 단위가 %로 되어있던 것을 어느 브라우저에서나 화면에 꽉 차게 보이게 하기위해서 vh 단위로 바꾸었다. css 단위에 대해서는 아직 부족한 부분이 많기 때문에 앞으로 더 공부해 나갈 것이다. css 단위 참고 블로그 그리고 나서 각자의 코드를 합치기 전에 주석을 비롯해서 정리하고 git을 이용하여 팀원들이 pull request를 하고 pm인 내가 merge를 승인하여 코드를 합쳤다. 다행히도 conflict 난 부분이 많지 않아서 금세 안정적으로 프로젝트 결과물을 제출할 수 있었다. 프로젝트를 진행하면서 느낀점이 많이 있었다. 첫번째로 무작정 코딩을 진행하기 보다는 그 전에 확실히 어떤 라이브러리를 사용할 것인지, 어떤 기능을 만들 것인지, 전체적인 플로우는 어떻게 진행될 것인지 등을 오랜 시간을 들여 하는 것이 중요하다는 것이다. 코딩을 하는 시간이 짧아지면 왠지 모를 불안감이 생기지만 분명히 시간상으로도 프로젝트의 완성도를 생각할 때에도 무작정 코딩하는 것보다는 미리 완벽히 설계하고 들어가는 것이 중요하다. 팀원들과의 의사소통이 정말 중요하다. 팀원들끼리 현재 진행상황이나 문제점, 새로운 아이디어 등을 공유하면서 프로젝트를 진행하면 훨씬 높은 완성도의 결과물이 나올 수 있을 것이라 생각한다. 3월 28일 (목) 오늘은 어제 count 변수를 증가시키며 동적으로 생성한 클래스를 이용한 코드 에서 포스트잇을 삭제하였다가 다시 만들 때 와 로드 할 때 문제가 생겨서 문제를 해결하는데 많은 시간을 소비하였다. 문제해결을 하기 위해서 먼저 문제의 원인을 파악하는데 집중하였다. 문제의 원인은 비교적 간단하였다. 삭제할 때와 로드할 때 count 변수의 어떤 변화도 주지 않기 때문이었다. 그래서 삭제할 때는 count– 를 주고 road 할 때는 새로운 조건을 주어 문제를 해결하였다. 프로젝트의 마지막 기능인 배경 이미지를 변경하는 기능을 만들었다. 배경이미지를 img태그를 이용하여 준 것이 아니라 background: url attr()을 사용할 수 없었다. 그래서 css()를 활용하여서 썸네일 이미지를 클릭하면 그 이미지로 배경이 바뀌는 기능을 구현하였다. 3월 27일 (수) 오늘은 to-do-list의 핵심 기능인 메모(?)을 만들어서 입력, 삭제, 로컬스토리지 저장 기능까지 완료하였다. 우리 팀 to-do-list의 특징적인 부분은 글만 보이게 하는 것이 아닌 동적인 느낌을 주기 위해서 글을 입력하면 포스트잇이 화면에 생성된다. 이 부분이 기존 to-do-list보다 어려운 부분이었다. 기존 to-do-list는 list 각자 따로 css를 줄 필요가 없이 li 태그나 p 태그 등을 활용하면 알아서 밑으로 정렬되었지만 포스트잇은 각각의 위치가 잡혀 있어야하고 그렇게 하기 위해서는 각각 css를 이용하여 위치를 잡아주어야 했다. 그래서 처음 생각한 부분이 class를 각자 따로 주고 그 class 각각의 css를 주는 것이었다. 클래스를 동적으로 생성하기 위하여 count 변수 숫자를 증가시키고 그 count 변수와 문자열을 더한 값을 변수에 저장하여 addClass()를 통하여 각각의 포스트잇에 각기 다른 class를 추가하였다. 그리고 로컬스토리지에 저장할 때 class를 저장하고 불러올 때 class를 불러오게 하여서 포스트잇 각각의 위치를 저장하고 불러올 수 있게 하였다. 이 방법이 좋은 방법인지는 아직 모르겠지만 마음에 들지 않는다. 앞으로 더 공부해나가면서 더 좋은 방법이 떠오른다면 꼭 변경해보고 싶은 코드이다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190326_TIL(프로젝트 2일차)","slug":"190326-TIL-프로젝트-2일차","date":"2019-03-26T15:38:04.000Z","updated":"2019-04-12T15:23:11.880Z","comments":true,"path":"2019/03/27/190326-TIL-프로젝트-2일차/","link":"","permalink":"http://progyu.github.io/2019/03/27/190326-TIL-프로젝트-2일차/","excerpt":"","text":"3월 26일 (화) 어제 날씨 api를 이용하여 만든 기능은 온도, 습도, 구름량 등 많은 데이터를 알려주지만 데이터를 가져올 때 내가 위치를 지정해주어야만 했다. ##예) 서울의 날씨 데이터, 런던의 날씨 데이터## 이 정도 기능에 만족할 수는 없었고 내가 지금 현재 위치한 장소에 날씨 데이터를 받아오고 싶었다. 어떻게 기능을 구현할 수 있을지 생각해보니 이전 수업에서 자바스크립트로 내가 현재 위치한 위도와 경도 값을 얻어오는 것을 했던 기억이 떠올랐다. 그래서 어제 이용한 openweathermap 사이트에서 위도와 경도 값으로 위치를 찾아서 날씨 데이터를 넘겨주는 기능을 제공해주는지 찾아봤다. doc에서 찾아보다가 By geographic coordinates 라는 항목에서 제공을 해준다는 것을 알아내었다. API를 불러오는 Example은 api.openweathermap.org/data/2.5/weather?lat=35&amp;lon=139 이러하다. 이제 자바스크립트로 작성을 해야하는데 막막했다. 결국 검색을 통하여 해결책을 찾아냈다.노마드코더 해결책은 바로 이것이다. 동영상으로 학습하며 결국 해내었다. 날씨 기능 완료! 날씨 기능을 완료하고 to-do-list 작업을 진행하였다. 먼저 이전에 팀원들과 논의하여 사용할 컨텐츠들을 화면에 어디에 배치할지 좋을지 생각하고 그 다음 html, css 작업을 진행하였다. 우리 팀이 만들어내야할 결과물은 carousel 안에 컨텐츠를 집어넣어서 마치 여러 페이지가 있는 것처럼 보이게 하는 것이 핵심이었다. Bootstrap을 활용하면 carousel을 쉽게 만들 수 있지만 내가 원하는 대로 커스터마이징 하기 어렵다고 판단하여 html,css,javascript 만으로 구성된 carousel을 만들고 싶었다. 하지만 프로젝트 기간이 짧고 쉽게 만들 수 있다고 판단이 되지 않아서 검색을 하여 결국 찾아내었다.w3schools 유명한 사이트인 w3schools에서 찾았다. 이 사이트 how to 탭에는 유용한 정보들이 많이 있다. 그 중 내가 마음에 드는 몇 가지를 소개하겠다.Full page, Toggle password visibility, Multi Step Form, Meet the team page 오늘 프로젝트를 진행하며 느꼈던 점 과 새롭게 알게된 점 Bootstrap 이나 material design lite 같은 프레임워크를 중간에 사용하면 기존에 코드에 영향을 미칠 수 있다. input 태그 같은 inline 요소를 display:block; 로 지정해도 text-align:center가 적용되지 않는다. input 태그를 중앙에 배열하기 위하여 나는 input 태그를 div로 감싼 text-align:center를 적용하였다. visibility:hidden 속성을 이용하여 태그들의 배치나 정렬을 도울 수 있다. git은 팀원이 fork를 떠서 같은 파일을 서로 각기 작업했을 때 시너지가 좋다. develop branch에서 feature branch를 딴 순간 develop branch에 있는 내용이 새로 딴 feature branch에 복제되어 넘어간다. 어느 한 branch에서 작업을 하던 중 git bash를 꺼도 다음에 다시 git bash를 켜고 같은 경로로 들어가면 마지막에 위치해있던 branch로 되어있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190325_TIL","slug":"190325-TIL","date":"2019-03-25T15:08:52.000Z","updated":"2019-04-12T15:23:06.362Z","comments":true,"path":"2019/03/26/190325-TIL/","link":"","permalink":"http://progyu.github.io/2019/03/26/190325-TIL/","excerpt":"","text":"3월 25일 (월) 오늘은 프로젝트 첫째날이다. 앞으로 5일 동안 프로젝트가 진행된다. 팀원들과 프로젝트 주제를 선정하기 위하여 많은 의견을 나누었다. 게임 홍보 페이지, 크롬 웹 익스텐션, 패럴렉스, 불꽃놀이 축제 홍보 페이지 등등 많은 아이디어가 나왔다. 많은 고민을 거듭한 끝에 그동안 배운 내용들을 복습하기 가장 좋은 주제로 선정하였다. 주제는 바로 naver에서 출시한 브라우저인 whale이다. whale의 디자인과 기능을 벤치마킹하기로 했다. 역할 분담은 인원에 맞춰서 총 세 파트로 구성하였다. 첫번째 파트는 to-do-list, 현재 시각과 날씨 정보 표기 그리고 화면 테마 변경, 두번째 파트는 다이어리, 디데이 마지막 파트는 공통으로 들어가는 요소인 사이드바에 계산기 , 환율, 음악검색 api 등의 기능을 구현하는 것이다. 나는 첫번째 파트를 맡게 되었다. git flow로 작업할 feature branch를 생성하고 작은 기능 단위인 날씨 api 기능을 진행하였다. 먼저 어떤 api를 사용할지 검색을 하였다. 네이버, 다음, 구글과 같은 곳에서는 날씨 api를 제공하지 않았다. 상당히 많은 시간을 검색한 끝에 openweathermap이라는 해외사이트에서 제공하는 api를 사용하기로 했다. 홈페이지와 다른 사람의 개인 블로그를 참고하였다. ajax를 이용하여 JSON 형식의 데이터를 전송 받았다. 디자인적으로 예쁜 날씨 아이콘을 사용하기 위하여 아이콘을 사용하였다. 위 사이트에서 다운을 받아 css 폴더와 font 폴더를 작업 중인 폴더에 복사하고 html 파일에 링크를 걸어 사용하였다. jquery로 아이콘과 날씨 데이터를 html에 매핑하고 css를 이용하여 디자인 작업을 진행하였다. 작은 공간에 많은 데이터를 넣고 정렬하는 것이 쉽지 않았다. 머리 속으로 생각하고 실제로 그려보면서 어떻게 정렬할지 시뮬레이션 하고 코딩하였다. 결과적으로는 예쁜 디자인의 날씨 데이터를 보여주는 기능을 만들어서 매우 뿌듯했다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"190319-0322_TIL(local storage, git flow, git fork, api)","slug":"190319-0322-TIL-local-storage-git-flow-git-fork-api","date":"2019-03-24T06:02:11.000Z","updated":"2019-04-12T15:22:58.947Z","comments":true,"path":"2019/03/24/190319-0322-TIL-local-storage-git-flow-git-fork-api/","link":"","permalink":"http://progyu.github.io/2019/03/24/190319-0322-TIL-local-storage-git-flow-git-fork-api/","excerpt":"","text":"3월 22일 (금) 쇼핑몰 상품 상세 페이지 copy 과제를 했다. 과제를 진행하던 중 div 태그를 display:inline-block으 사용하여 서로 같은 라인에 배치를 하였는데 이상하게도 윗 공간에 아무 요소도 없는데 오른쪽 div가 맨 위에 붙지 않고 제멋대로 붙었다. 고민을 거듭해도 답을 알 수가 없어 클래스 매니저님에게 물었더니 inline-block으로 묶으면 윗줄을 기준으로 붙는 것이 아니라 base-line을 기준으로 붙기 때문에 div의 height가 서로 다를 시 에는 윗줄의 붙지 않는 다고 하셨다. 해결책인 의의로 간단하였다. vertical-align 속성을 사용하여 요소를 위(top), 중간(middle), 아래(bottom)에 배치할 수 있었다. 자바스크립트 변수의 범위(scope)와 호이스팅(Hoisting)`에 대해서 배웠다. 수업시간에 짧게 배운 내용이 잘 이해가 가지 않아서 자료를 검색하던 중 잘 정리된 블로그를 발견하였다. 변수의 범위와 호이스팅 변수는 지역 범위(local scope)와 전역 범위(global scope) 둘 중 하나를 가진다. 대부분의 프로그래밍언어가 블럭 수준의 범위를 가지고 있는 것과 달리 자바스크립트에서는 지역 변수가 함수 수준8의 범위를 가진다. 함수 내에 정의된 변수는 지역 범위를 가지며, 해당 함수와 내부 함수에서만 접근이 가능하다. if문과 같은 블럭{} 수준에서 변수 선언 시 지역 변수가 아닌 전역 변수임을 유의해야 한다. 함수 안에서 지역 변수를 선언할 때는 var 키워드를 사용한다. 지역 변수는 함수 내에서 전역 변수보다 높은 우선 순위를 가진다. 함수의 외부에서 선언된 모든 변수는 전역 범위를 가진다. 전역 변수는 var 키워드를 사용해도 되고 사용하지 않아도 된다. 가급적 전역 범위에 변수를 생성하는 것을 피해야 한다. 호이스트란, 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것을 의미 즉, 변수가 함수 내에서 정의되었을 경우 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우는 전역 컨텍스트의 최상위로 변경 호이스트 되었을 때, 함수 선언은 변수 선언을 덮어 쓴다. 하지만, 변수에 값이 할당된 경우 반대로 변수가 함수 선언을 덮어 쓴다. 3월 21일 (목) 오늘은 naver map api를 사용하여 기본적으로 지도를 화면에 표시하고 마커를 표시하고 정보창을 표시해보았다. 네이버 api를 사용하기 위해서는 먼저ncloud 에서 회원가입을 진행하고 이용신청을 하면된다. 그리고 실제로 사용을 위해서는 navermaps에서 Tutorials를 살펴보면 된다. 오늘 배운 것중 가장 신기했던 부분은 이전에 사용했던 다음 주소 api 와 네이버 지도 api를 연결해서 사용했던 부분이다. 다음 주소 api에서 검색한 주소 값을 받아서 네이버 지도 api에서 위도,경도 값으로 변환하여 그 위치에 마커를 찍을 수 있었다. 이런 기능은 geocoder 서브 모듈을 활용해야 한다. 3월 20일 (수) 오늘은 git 수업 날이었다. git flow와 git fork를 학습하였다. git flow는 git의 branch 기능을 좀 더 원활하고 쉽게 사용할 수 있게 만들어 버전관리를 용이하게 하는 확장 기능이고 git fork는 git을 사용하는 가장 주된 이유 중 하나인 협업을 할 수 있게 해주는 기능이다. 처음 접해보는 기능들이라 조금은 어려웠지만 그래도 팀원들과 함께 git fork를 테스트 하는 것까지 별다른 문제없이 성공하였다. git을 활용할 때는 팀원들 간의 의사소통이 정말 중요하다고 느꼈다. 3월 19일 (화) 오늘은 local_storage에 대해 배웠다. server 없이도 내 컴퓨터를 활용하여 웹에 있는 값을 저장할 수 있다니…! 브라우저를 닫고 열어도 다시 그 값이 들어있었다. 매우 신기했다. 하지만 내용은 어려웠다. 한달 동안의 수업 컨셉이 빠르게 한번 익혀보자는 것이기 때문인지 객체나 JSON의 대한 설명이 거의 없었다. 잘 모를 때는 역시 인터넷 검색으로! 아직도 잘 이해되지 않는 부분들이 많지만 열심히 배우고 또 배우면 금세 이해할 수 있을 것이다!! localstorage JSON 간단 JSON 자세히 객체","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"git-flow 사용하기","slug":"git-flow-사용하기","date":"2019-03-24T02:26:54.000Z","updated":"2019-04-12T15:24:13.389Z","comments":true,"path":"2019/03/24/git-flow-사용하기/","link":"","permalink":"http://progyu.github.io/2019/03/24/git-flow-사용하기/","excerpt":"","text":"git flow란 ? Vincent Diessen의 branching model을 적용하여 저장소를 관리할 수 있도록해주는 확장기능 feature - develop - release - hotfixes - master 단계로 branch를 나누어서 버전을 관리하는 전략. branch 관리를 위한 확장 명령어를 제공하는 역할만 하기 때문에 기존의 git 명령어로도 이를 그대로 구현 가능 내 나름대로 정의를 해보면 ‘branch를 사용하기 위하여 처리해야 하는 귀찮은 일련의 작업을 쉽게 처리할 수 있게 도와주는 확장 기능’ git flow로 만들 수 있는 branch 6종 master : 최종 릴리즈에 사용되는 안정된 버전 develop : 다음 릴리즈를 위해 개발중인 최신 버전 feature : 특정 기능 개발을 위한 branch release : 릴리즈 점검을 위한 branch hotfix : 긴급 버그 픽스를 위한 branch support : 버전 호환성 문제를 처리하기 위한 branch 설치 git flow는 OSX, Linux, Window 환경에서 동작한다. git bash에는 기본으로 설치가 되어있다. 필자는 git bash를 사용. git bash 설치 git flow 시작하기 작업을 진행할 git 저장소에서 다음 명령어를 통해 초기화 한다. 1$ git flow init git flow init 명령어를 사용하면 branch 이름을 입력하라는 메세지가 출력된다. 이 과정을 생략하려면 아래 명령어를 사용한다. 1$ git flow init -d 특정 기능 개발을 하기 위한 branch는 feature를 사용한다. feature에서 git flow를 시작하기 위해서는 아래 명령어를 사용한다. 1$ git flow feature start &#123;branch_name&#125; 자동으로 해당 branch로 checkout 된다. 해당 branch에서 기능 개발이 완료하면 아래 명령어를 입력한다. 1$ git flow feature finish &#123;branch_name&#125; feature finish 명령어를 실행하면 자동으로 아래의 일련의 과정들을 수행한다. develop branch로 checkout feature branch의 작업 내용을 develop branch에 merge 작업이 끝난 feature branch를 삭제 만약 해당 feature branch가 존재했다는 사실을 github page에 남기고 싶으면 commit 메세지를 작성하면 된다. 만약 해당 branch를 merge 하지않고 삭제하고 싶다면 아래 명령어를 사용한다. 1$ git branch -D &#123;branch_name&#125; Release 하기 release를 하기 위해서는 아래 명령어를 사용한다. 1$ git flow release start &#123;version&#125; 위 명령어를 실행하면 develop branch의 내용을 바탕으로 release/{version}의 이름을 갖는 새로운 branch를 하나 생성하여 checkout 한다. version은 보통 v0.0.1형식으로 작성한다. 정식버전이 출시되면 v1.0.0 처럼 가장 앞의 숫자를 증가시키고 핵심 기능의 변화 등은 v1.1.0 작은 기능의 변화 등은 v1.1.1의 형식으로 작성한다. release를 위한 점검이 종료되면 release를 finish 한다. 1$ git flow release finish &#123;version&#125; release finish 명령어를 실행하면 자동으로 아래의 일련의 과정들을 수행한다. release branch의 code를 master branch에 merge 한다. release의 이름으로 태그 등록 release를 develop branch로 재병합 release branch 삭제","categories":[{"name":"Git","slug":"Git","permalink":"http://progyu.github.io/categories/Git/"}],"tags":[]},{"title":"Git fork를 활용하여 협업하기","slug":"Git-fork를-활용하여-협업하기","date":"2019-03-24T01:28:03.000Z","updated":"2019-04-12T15:24:24.592Z","comments":true,"path":"2019/03/24/Git-fork를-활용하여-협업하기/","link":"","permalink":"http://progyu.github.io/2019/03/24/Git-fork를-활용하여-협업하기/","excerpt":"","text":"이 포스트는 실제 협업 사례가 아닌 수업 내용을 토대로 하여 git fork 기능을 테스트 해본 경험임을 알려드립니다. Pm 파트 Pm이 새로운 repository를 생성한다. Pm이 clone을 하여 문서를 생성한다. 생성한 git 문서 경로롤 이동한다. develop branch를 하나 생성한다. (사실 git flow를 활용하여 작은 기능 단위를 작업하는 feature branch에서 작업해야함.) develop branch 로 checkout 한다. 파일을 생성하고 작성한 후 add, commit, push를 진행한다. 실제 코드를 작성하는 개발자 파트 pm의 repository에서 fork 한다. fork를 하면 pm과 같은 이름의 fork된 repository로 이동하고 닉네임 옆에 포크 아이콘이 표시된다. clone or download 버튼을 클릭하여 pm의 repository 주소를 복사하고 작업할 폴더에 clone 한다. 다음 명령어를 통해 pm의 branch 까지 전부 확인할 수 있다. 1git branch -a 다음 명령어를 통해 원본 repository를 로컬 git repository의 원력 등록한다. 1git remote add &#123;repository_nickname&#125; &#123;pm의 git_url&#125; develop branch를 생성한다. develop branch로 checkout 한다. 다음 명령어 원본 repository를 full한다. 1git pull &#123;repository_nickname&#125; &#123;branch_name&#125; pull을 실행하면, 원본 repository의 내용을 가져와 자동으로 병합 작업을 실행한다.단순히 원본 repository의 내용을 확인만하고 로컬 repository와 병합하고 싶지 않은 경우 다음 명령어를 실행한다. 1git fetch &#123;repository_nickname&#125; 그 후 병합하고 싶은 경우에는 다음 명령어를 실행한다. 1git merge &#123;respository_nickname&#125;/&#123;branch_name&#125; 원본 repository에 있는 파일을 작업하고 add, commit, push 한다. push를 할 때는 자신의 branch에서 push 한다. 1git push origin &#123;branch_name&#125; push를 하면 개발자가 fork한 github page에 compare &amp; pull request 버튼이 활성화 된다. 버튼을 클릭하고 메세지를 작성한 후 pm의 repository의 branch와 자신의 repository를 비교하여 자신이 보내는 위치의 branch와 보내려고 하는 branch를 확인한 후 create pull request 버튼을 클릭한다. 다시 pm 파트 github 페이지 repository를 확인하면 pull requests 탭에 숫자 1이 생겼을 것이다. pull requests 탭을 클릭하면 개발자 commit 메세지를 확인할 수 있고 클릭을 하면 merge를 할 수 있는 화면이 나온다. 이 화면에서 pm은 merge를 할지 말지 결정할 수 있고 개발자와 대화를 나눌 수도 있다. merge 버튼을 클릭하고 confirm merge 버튼을 재차 클릭하면 merge가 완료 되었다는 화면이 나타난다. 다른 화면으로 이동하면 pull requests 탭에 숫자 1이 사라진 것을 확인할 수 있다. code 탭으로 이동하여 develop branch를 선택하고 파일을 확인해보면 개발자가 작업한 내용이 pm의 repository에 잘 merge 된 것을 확인할 수 있다.","categories":[{"name":"Git","slug":"Git","permalink":"http://progyu.github.io/categories/Git/"}],"tags":[]},{"title":"190318_TIL","slug":"190318-TIL","date":"2019-03-18T11:05:46.000Z","updated":"2019-04-12T15:22:52.573Z","comments":true,"path":"2019/03/18/190318-TIL/","link":"","permalink":"http://progyu.github.io/2019/03/18/190318-TIL/","excerpt":"","text":"3월 18일 (월) 수업 시작하자마자 CSS만을 활용하여 메뉴를 생성하는 과제를 했다.매번 Bootstrap을 이용하여 쉽게 만들다가CSS만 활용하여 만들려고 하니 많이 어려웠다.강사님이 github에 올려주신 자료로 복습해야겠다. 다음 우편번호 서비스 api을 활용하여 회원가입 폼을 만들고 공백과 정규표현식을 활용하여 validation(유효성)검사까지 진행하였다. 다음 우편번호 서비스 api는 사용방법이 간단하며, 웹페이지에도 친절하게 설명이 되어있다. data 라는 객체에 사용자가 선택한 주소 정보를 담고 있다.따라서, 입력한 주소의 우편번호 값을 가져오고 싶으면 data.postcode 와 같은 형식으로 값을 받아올 수 있다.","categories":[{"name":"TIL","slug":"TIL","permalink":"http://progyu.github.io/categories/TIL/"}],"tags":[]},{"title":"First use of hexo","slug":"First-use-of-hexo","date":"2019-03-17T14:43:37.000Z","updated":"2019-04-12T15:23:59.841Z","comments":true,"path":"2019/03/17/First-use-of-hexo/","link":"","permalink":"http://progyu.github.io/2019/03/17/First-use-of-hexo/","excerpt":"","text":"Hexo를 이용하여 gitblog 글 작성하기git repository 생성하기 자신의 [github name].github.io 로 repository를 생성한다. node 설치하기 Hexo를 이용하기 위해서는node 설치가 필요합니다. Hexo 설치하기 Hexo는 아래 명령어를 사용하여 설치한다. 1$ npm install -g hexo-cli 웹사이트 초기화하기 Hexo를 초기화 하기 위해 아래 명령어를 사용한다. 123$ hexo init [folder]$ cd &lt;folder&gt;$ npm install 새 글 생성하기 새 글(article)을 생성한다. layout이 준비되어 있지 않다면, _config.yml에 정의된 default_layout을 사용. 만약 title에 공백이 포함된다면 따옴표로 감싸주어야 한다. 1$ hexo new [layout] &lt;title&gt; 글 작성하기 위에서 생성한 새 글은 .md 파일 형식으로 생성된다. 새로 생성한 .md 파일은[프로젝트 폴더]/source/_posts/&lt;title&gt;.md 이 경로에 있다. 에디터를 이용하여 Markdown 형식으로 작성하면 된다. 정적 파일 생성하기1$ hexo generate [파일명] github 블로그는 html 파일형식으로 올라가야 한다. 따라서, Hexo로 제작된 .md 파일을 generate 커맨드를 사용하여 변환해주어야 한다. generate를 하기 위해서는 작성한 .md 파일이 있는 경로([프로젝트 폴더]/source/_posts/)로 이동하여야 한다. server로 미리 확인하기1$ hexo server 로컬 서버를 구동시킨다. 기본적으로 http://localhost:4000/ 를 사용. git에 deploy 하기 hexo-deployer-git을 설치한다. 1$ npm install hexo-deployer-git --save _cofig.yml 파일에서 url을 수정한다. http://자신의 [github name].github.io 로 url을 수정 한다. _cofig.yml 파일 가장 밑에 작성.123deploy: type: git repo: 자신의 [repository url] 웹사이트를 deploy 하기1$ hexo deploy 첫 번째 이후 github 블로그 작성 new, generate, server, deploy 4개의 명령어만 사용하면 된다. 느낀점 Hexo를 처음 이용하여 생소하고 어려웠지만 익숙해지면 편리하게 github 블로그를 관리할 수 있을 것 같다. Markdown 문법 공부에 많은 도움이 될 것 같다.","categories":[{"name":"HEXO","slug":"HEXO","permalink":"http://progyu.github.io/categories/HEXO/"}],"tags":[]},{"title":"How to start hexo","slug":"How-to-start-hexo","date":"2019-03-13T06:39:50.000Z","updated":"2019-03-13T06:48:38.807Z","comments":true,"path":"2019/03/13/How-to-start-hexo/","link":"","permalink":"http://progyu.github.io/2019/03/13/How-to-start-hexo/","excerpt":"","text":"How to start Hexo안녕하세요. progyu 입니다. 오늘은 hexo를 이용해 블로그를 생성하는 방법에 대해 알아보겠습니다. (이모티콘 - 개구리 - 데헷)","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-03-13T06:32:47.752Z","updated":"2019-03-13T06:32:47.755Z","comments":true,"path":"2019/03/13/hello-world/","link":"","permalink":"http://progyu.github.io/2019/03/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}